<?php

function inmersa_session_recover() {
	// debug("Haciendo el recovery .. ");
	$bStartUp = true;
	$lout = $GLOBALS['logout'];
	if ((bool)$lout) {
		session_destroy();
		unset($GLOBALS['INMERSA_BASEDB']);
		session_start();
	}
	if (!is_a($GLOBALS['INMERSA_BASEDB'],'wol_db')) {
		// debug("_constructor_ pristine db .. ");
		$GLOBALS['INMERSA_BASEDB'] = new wol_db($GLOBALS['APP_NAME']);
	}

	if (is_a($GLOBALS['INMERSA_BASEDB'],'wol_db')) {
		// debug("_existe_ nuestra db .. ");
		$oDb = &$GLOBALS['INMERSA_BASEDB'];
		$sId = session_id();
		// debug("Logout: ".$lout." sId: ".$sId);
		if (!empty($sId) AND !(bool)$lout) {
			// debug("Buscando la expiracion de la sesion... ".$_SESSION['session_expiretime']);
			$cons = 'SELECT valor FROM Users_sessions WHERE sessid = "'.$sId.'" AND app_name = "'.$GLOBALS['APP_NAME'].'" ';
			$srs = $oDb->query($cons);
			// debug($cons." nrs: ".$oDb->num_rows($srs)." db: ".$oDb->get_dbase_name());
			if ($oDb->num_rows($srs)) {
				// debug("Hemos encontrado la sesion!! $sId ");
				$aTmp = $oDb->fetch_row($srs);
				// debug("el resultao del hash : ".md5($aTmp[0])." O una length de ".strlen($aTmp[0])." O ".round(strlen($aTmp[0])/1024,3)." KB ");
				$GLOBALS[$GLOBALS['APP_NAME']] = unserialize($aTmp[0]);
				$GLOBALS[$GLOBALS['APP_NAME']]->_aKrnConf['recovered_session'] = true;
				// print_r($GLOBALS[$GLOBALS['APP_NAME']]);
				$GLOBALS[$GLOBALS['APP_NAME']]->set_db('conf',&$oDb,true);
				$bStartUp = false;
			}
		} else $bStartUp = true;
	} else $bStartUp = true;

	if ($bStartUp) {
		// debug("StartUp = True ... construimos nueva instancia. ");
		if (is_array($_POST) AND sizeof($_POST) AND !is_array($_SESSION['post_before_login'])) {
			$_SESSION['post_before_login'] = $_POST;
		}
		if (!is_object($GLOBALS[$GLOBALS['APP_NAME']]) OR strcmp($GLOBALS[$GLOBALS['APP_NAME']]->App_Name,$APP_NAME)) {
			// debug("inmersa_session_recover() - start: $bStartUp ");
			$GLOBALS[$GLOBALS['APP_NAME']] = new wolSesion($GLOBALS['APP_NAME'],$GLOBALS['APP_NAME']);
		} 
	}

}

/**
* Aplicacion diseñada para Web On Line Studios S.L.
*    Todos los derechos reservados.
*    Este programa se podra modificar con el consentimiento
*    de Web On Line Studios S.L. Su distribucion queda
*    limitada a Web On Line Studios S.L.
*    Las posibles modificaciones sobre esta aplicacion ajenas
*    a Web On Line Studios S.L. deberan ser consultadas y
*    enviadas a Web On Line Studios en C/Alcala 18 3º Izda,
*    28014 Madrid. Cualquier otra operacion realizada sobre
*    esta aplicacion queda limitada a Web On Line Studios S.L.
*    infringiendo en delito cualquier otra entidad que asi lo
*    hiciese.
*
* Para mas informacion referente a la licencia de esta
*    aplicacion referirse al fichero LICENCIA. Caso de que Ud.
*    no tenga una copia de este fichero, contacte con Web On
*    Line Studios S.L. para recibir una copia del mismo
*
* Informacion de Contacto
*    Josafat Moragrega Fernandez
*    Engineering
*    Director Tecnico
*    tite@wolstudios.com
*    C/Alcala 18 3º Izda, 28014 Madrid, España
* @author    Josafat Moragrega Fernandez
*
* @copyright  Web On Line Studios S.L.
*
*/

/*
* $Id: sesiones.inc,v 1.1.2.1.4.22.4.11.4.49.2.12.2.6 2008-01-30 20:05:41 tite Exp $
* $Header: /srv/cvsroot/gestion/escritorio/kernel/sesiones.inc,v 1.1.2.1.4.22.4.11.4.49.2.12.2.6 2008-01-30 20:05:41 tite Exp $
* $Author: tite $
* $Date: 2008-01-30 20:05:41 $
* $Name:  $
*/

/* Este modulo tiene como objeto crear un objeto sesion con unos atributos
   y unos metodos que permitan la comunicacion entre los distintos modulos
   de un portal web.
   Presunciones :
   - Esta funcion necesita usar el modulo db.inc, asi como tener una instancia
de WOl_db en la variable $oDb, la cual habra de ser global.
 */

define('IKRN_VAR_CRC_KEYMATCH',			bindec('00001'));
define('IKRN_VAR_CRC_VALUEMATCH',		bindec('00010'));
define('IKRN_VAR_CRC_MATCH',			bindec('00011'));
define('IKRN_VAR_CRC_NEW',					bindec('00100'));
define('IKRN_VAR_CRC_CHANGE',			bindec('01000'));
define('IKRN_VAR_CRC_AUTHED',			bindec('10000'));

define('IKRN_VAR_ORIG_POST',			bindec('00001'));
define('IKRN_VAR_ORIG_GET',				bindec('00010'));
define('IKRN_VAR_ORIG_REQUEST',			bindec('00100'));
define('IKRN_VAR_ORIG_GLOBAL',			bindec('01000'));

define ('DBUG_DB',		bindec ("00000001"));
define ('DBUG_INC',	bindec ("00000010"));
define ('DBUG_VARS',		bindec ("00000100"));
define ('DBUG_MODS',		bindec ("00001000"));

class wolSesion {
	/*
	 * Configuracion General de la sesion 
	 */

	/**
    *Nombre de la App donde esta esta seccion
    */
	var $App_Name;

	/*
	 * Tablas de configuracion (esto tendria k estar en 1 sola tabla, pero weno 
	 */

	/**
   * Tabla donde estan todas las secciones
   */
	var $tb_secciones;
	/** * Tabla relacional entre Secciones y SubSecciones (screens)*/
	var $tb_sec_subsecc;
	/*** Tabla con las Sub-secciones (se tratan como si fuesen secciones)                    */
	var $tb_sub_secc;
	/*** Tabla que relaciona secciones(sub) con plantillas                              */
	var $tb_sub_plts;
	/*** Tabla donde estan todas las plantillas  */
	var $tb_plantillas;

	/**
   * Configuracion General del Kernel 
	*	register_globals	-	Si el get ha de obtener las variables recibidas por QUERY_STRING (como si fueran de sesion)
	**/
	var $_aKrnConf = array (
		'register_globals' => FALSE,		// Si register_globals esta activado.
		'doc_root' => NULL,					// Ruta al virtualhost raiz de la aplicacion
		'plt_path' => NULL,					// Ruta relativa a las plantillas 
		'scripts_path' => NULL,				// Ruta relativa a los scripts 
		'locale_path' => NULL,				// Ruta al directorio de los msgs por idioma
		'locale_kernmsgs' => NULL,			// Fichero con los mensajes del Kernel. 
		'locale_sysdefault' => NULL,		// Locale de sistema predefinido
		'default_subsecc_fo' => NULL,		// Sub-Seccion por defecto del FO
		'default_subsecc_bo' => NULL,		// Sub-Seccion por defecto del BO
		'default_iface' => NULL,			// InterFace por Defecto
		'default_lang' => NULL,				// Idioma por Defecto
		'default_theme' => NULL,			// Tema por Defecto
		'format_data' => FALSE,				// Se formatean los datos obtenidos de la bbdd.
		'session_expiretime' => 0,			// Duracion, en horas, de la sesion
		'db_logpath' => '',					// Ruta a los logs de acceso a la bdd
		'css_hide' => '',						// Estilo para la ocultacion de campos
		'nomodule_subsecc' => '',			// Subseccion caso de no negar acceso a una ss por pertenecer a un modulo distinto
		//ONTheFly 'recovered_sesson' => false			// Si la sesion ha sido recuperada de la bdd o no
		'action_access' => FALSE			// Control de acceso a acciones (bool: activacion)
			);

	/*
	 * RUTAS Y PATHS 
	 */

	/**
   * Directorio donde reside el document root */
	var $root_dir;

	/**
   * Directorio(relativo) de imagenes por subsec*/
	var $img_dir = "catalogo/";
	var $script_dir = "NOscripts/";	/* Directorio donde residen los scrips */

	/** Informacion de (SUB)Secciones **/

	/**
   * nombre identificativo de la seccion anterior
   * (aki faltaria con un nombre de visualizacion, hay k mirar a ver si esta contemplado en la tabla Sub_Secc, sino ponerlo. */
	var $old_secc_name;
	/*** id de la sub_secc anterior */
	var $old_secc;
	/*** QUERY_STRING de la seccion anterior */
	var $old_secc_querystring;
	/*** Nombre de la seccion */
	var $seccion;
	/*** Tabla base de la seccion(subsecc) actual */
	var $tb_base;
	/*** Nombre de la seccion por defecto (obsolete) */
	var $def_secc;
	/*** Id de la SUBseccion en la tabla de Sub_Secc */
	var $id_secc;

	var $_aSeccion = array();	// Datos de la Sub-Seccion actual
	var $_seccion = array(); 	// Datos de la Seccion actual

	/**
   * Nos indica si ha sido recargada la pg o no */
	var $bRecarga = 0;

	/*
	 * Informacion de Plantillas 
	 */

	var $_aPlantillas = array();
	/*** Una seccion puede tener varias plantillas */
	var $plantillas = array ();

	/**
   * Puntero a la plantilla que toca */
	var $plt_point = 0;

	/**
   * Puntero a la ultima plantilla */
	var $plt_point_end = 0;

	/**
   * Directorio de las plantillas */
	var $plt_dir;

	/**
   * Script donde estan las funciones que necesitan las plantillas */
	var $include;

	/**
   * Funciones a Ejecutar por las distintas Plantillas (pos 0 = pre_code, 1=post_code) */
	var $code = array (array ());

	/**
   * Nombre de variable (o array) de argumentos pasables a cada plantilla */
	var $plt_arg = array ();

	/**
	* Plantillas a Mostrar caso de solicitarse un punto de informacion no localizable */
	var $aNullPlt = NULL;

	/*
	 * LIBRERIAS LINCADAS : 
	 */
	/*
	 * Conexion DB 
	 */
	// var $db_conf;
	/*
	 * Objeto conexion a la db de configuracion 
	 */


	/**
	 * Objeto de conexion a la base de datos   
	 */
	var $db;
	/*
	 * Soporte Multiples conexiones db 
	 */

	/**
   * Array referencial de instancias wolDB  "nombre_de_conexion" => wolDB */
	var $dbs = array ();

	/**
   * Nombre de conexion db actual */
	var $db_name;

	/**
   * Soporte Conexiones Persistentes (reales)
   * Array referencial indicativo de conexion persistente  "nombre_de_conexion" => BOOL */
	var $dbs_pconn = array ();

	/*
	 * SOPORTE MODULOS * Tablas: Modulos y Modulos_SubSecc * Notas: * - Hay dos tipos de modulos. Los base y los de subsecciones.
	 * * - Los campos allow_mask y deny_mask de la tabla Modulos no son considerados * cuando se cargan los modulos base. * - La
	 * carga de modulos consta de 2 fases: Inclusion-Creacion(carga) e Inicializacion * - Justo despues de las conexiones DB se
	 * cargan los modulos base. * - Despues de la comprobacion de subseccion se cargan los modulos de subsecciones. * 
	 */

	var $modulos = array ();	  // class wolModule?
	var $_aModulos = array ();	  // Informacion sobre los modulos
	var $_aModList = array ();	  // Todos los modulos cargados, y su cfg
	var $_aAcciones = array(); 	// Lista de acciones y accesos por session
	var $_aIdxAccSS = array(); 	// Indice de acciones sobre entidades por subseccion
	var $_aActiveModules = array ();	  // Todos los modulos activos para esta subsec

	/**
     * Jerarkia de Accesos 
	  */

	/**
	 * Objeto contenedor de la instancia de validacion (wolAV)
	 */
	var $Access = NULL;

	var $_aIfaces = array(			// Lista de Ifaces/Idiomas/Temas Disponibles en la app actual
			'iface' => array(),		// Array de Tipos de iface 
			'lang' => array(),			// Array de Idiomas
			'tema' => array()			// Array de Temas
			);		
	var $_aActiveIface = array (  // Iface/idioma/tema activos 
			'iface'	=> NULL,			// tipo de iface activo (id)
			'lang'	=> NULL,
			'tema'	=> NULL
			);

	/*
	 * Buscador 
	 */

	/**
	  * Objeto busqueda que nos indica el tipo de busqueda 
	 **/
	var $b_activa = "";

	/**
   * Variable Booleana que nos indica si el  motor de buskedas esta activo o no         */
	var $hay_b = 0;

	/*
	 * Menus 
	 */

	/**
   * Nos indica si esta seccion tiene o no menus */
	var $hay_menu = 0;

	/*
    * OBJETO menu que nos contendra todos los menus 
	 */
	var $menu = "";

	/*
	 * Instancia de control de Errores y Mensajes.
	 */
	var $oMsgs = NULL;

	 /**
	 * Variable de control de depuracion.
	 * 1 - Depuracion de los procesos de bases de datos y sesiones.
	 */
	var $debug = 0;


	/** Seccion de datos miscelaneos */

	/**
	  * Vector, indexado por entidad de la bbdd, contenedor de sus campos con la estructura del tipo de dato, y con 
	  *   las funciones de formato y parseo de datos predominantes a los de tipo de dato.
	  **/
	var $aEntityData = array( 'campo' => array(
			'struct' => array(),
			'format' => NULL,
			'parser' => NULL,
			'data_css' => NULL,
			'label_css' => NULL
			));

	/**
	  * Vector, indexado por tipo de dato de la bbdd, contenedor de 
	  *   las funciones de formato y parseo de datos predeterminadas a los de tipo de dato, asi como sus estilos.
	  **/
	var $_aDataFormats = array(
			'tipo' => array( 0 =>	// Longitud del campo
				array(
				'format' => NULL,
				'parser' => NULL,
				'data_css' => NULL,
				'label_css' => NULL
				) )
			);

	/**
	  * Lista de entidades 'visitadas' en la subseccion actual.
	  **/
	var $_aEntityList = array();
	var $_aCurEntityList = array();

	/**
   * Array de 2 dimensiones.
   Significado :
   *                             1(indice).- Indice del nombre de variable .
   *                             2(valor) .- valor de la variable */
	var $aData = array ();

	var $_aCrcCheck = array(		// Vector de Comprobaciones CRC32 sobre variables (GET y POST) y los tipos
			'var_name' => array(		//  Indexado por nombre de variable.
				'orig' => 0,			//		Contiene el origen de la variable.
				'crckeys' => 0,		//		CRC32 de las claves (si es una sequencia)
				'crcvalues' => 0,		//		CRC32 del valor(es) de la variable
				'status_last' => 0	//		Flags de estado con respecto a navegaciones anteriores (IKRN_VAR...)
				)
			);

	/**
	 * Array de configuracion del site actual
	 */
	var $configuracion = array (
			'def_secc' => NULL		// Subseccion por defecto.
			);

	/**
	  * Vector con plantillas de configuracion.
	  **/
	var $_aCfgPlts = array(
			'null' => NULL,			// Plt de 'plantilla no encontrada, o acceso denegado'
			'err_full' => NULL,		// Plt de Errores en los modulos (sustituye al pii-base)
			'err_pii' => NULL,		// Plt de Errores en el precode (sustituye el pii asociado al codigo fallido).
			'err_output' => NULL,	// Plt de salida de errores y mensajes.
			'emptysearch' => NULL	// Plt de salida de 'La busqueda no ha producido ningun resultado'
			);

		/**
        * Constructor
        * Constructor de sesiones
        *             Crea un objeto wol_db y lo conecta acorde a su configuracion
        * @param        $nombre  Nombre de sla aplicacion
        * @param        $var     Variable ke se crea en el index
        */
	function wolSesion ($nombre, $var) {
		$this->oMsgs = new IMessages();

		$this->App_Name = $nombre;

		$oDb = new wol_db($this->App_Name);
		// el new te crea un objeto ya conectado: $oDb->conecta();
		$this->set_db ("conf", $oDb, true);
		$this->activate_db ('conf');

		$this->_set_conf_tbs ();

		$this->_aDataFormats = NULL;
		$this->_setKrnCfg();

		/*
		 * Compatibilidad hacia atras.
		 */
		// $this->set_script_dir = $this->getFromConf("scripts_dir");
		// $this->root_dir = $this->getFromConf('doc_root');
		// $this->doc_root = $this->getFromConf('doc_root');

		$this->def_secc = $this->getFromConf('def_secc');

		$this->aEntityData = NULL;

		$this->_setIfaceList();

		$this->obj_var_name = $var;
	}

					 /********** PROTOTIPOS DE FUNCIONES ***************

                ****** Soporte Conexiones DB *******
                wolDB get_db(string db_conn_name)
                                ---> obtiene la instancia wolDB referenciada por db_conn_name o NULL
                bool  set_db(string db_conn_name,objeto wolDB,bool persistente)
                                --> pconns para
                set_db_conn(string db_conn_name,wolDB)
                                --> Establece la instancia wolDB BASE(this->db) en wolSession (no la de configuracion)
                wolDB get_db_conn(string db_conn_name)
                                --> obtener conexion actual O la conexion base(this->db)
                set_db(string db_conn_name,wolDB oDb)
                                --> establecer conexion actual O la base(this->db)
                wolDB get_db(string db_conn_name)
                                --> obtener instancia wolDB con el nombre <db_conn_name>
                reset_db(db_conn_name)
                                --> elimina la conexion del array de instancias wolDB
                string get_dbconname()
                                --> Obtener el nombre de la conexion actual.
                activate_db(string db_conn_name)
                                --> estable la db activa
                restore_dbspoints()
                                --> resetea puntero wolDB s a NULL para obtener wolDB base
                cerrar_dbs()
                                --> arregla todas las instancias wolDB para ser guardadas en la sesion
                conectar_dbs(db_conn_type)
                                --> reconecta TODAS las instancias wolDB si no coincide tipo con 'data' o 'conf'.
                                Caso de coincider conecta data o conf.
                *********************************


                ****** Soporte de Modulos *******
                load_internal_modules()


                **************************************************/

					 /**************** INIT ******************/

	/**
	* Obtenemos los parametros de configuracion del kernel.
	**/
	function _setKrnCfg () {
		$BACKOFFICE = wolSesion::fetchVar('BACKOFFICE','GLOBAL');

		$db = $this->get_db('conf');
		if (!is_object ($db)) return FALSE;

		if (is_array($this->_aKrnConf) AND sizeof($this->_aKrnConf)) {
			$tmpcons = NULL;
			foreach ($this->_aKrnConf as $var => $none) {
				// Ojito que esto crea dependencia severa con Zend
				$tmp = ini_get($var);
				if (empty($tmp) AND !is_numeric($tmp)) {
					//Ahora una sola query. $tmp = $db->read_main_value ('krncfg_'.$var);
					$tmpcons .= ((!empty($tmpcons)) ? ' OR ' : ' ').'nombre = "krncfg_'.$var.'"';
				} elseif (isset($tmp)) {
					$this->_aKrnConf[$var] = $tmp;
				}
				$tmp = NULL;
			}
			if (!empty($tmpcons)) {
				$cons = 'SELECT nombre,valor FROM _main WHERE '.$tmpcons;
				$cfgrs = $db->query($cons);
				if ($db->num_rows($cfgrs)) 
					while($aTmp = $db->fetch_assoc($cfgrs)) 
						$this->_aKrnConf[substr($aTmp['nombre'],7)] = $aTmp['valor'];
				$db->libera($cfgrs);
				$cfgrs = NULL;
			}
		}

		if (!empty($this->_aKrnConf['session_expiretime'])) {
			// debug("Hay tiempo de expiracion!! ");
			$_SESSION['session_expiretime'] = $this->_aKrnConf['session_expiretime'];
		}

		if (is_array($this->_aCfgPlts) AND sizeof($this->_aCfgPlts)) {
			$tmpcons = NULL;
			foreach ($this->_aCfgPlts as $var => $none) {
				$tmpcons .= ((!empty($tmpcons)) ? ' OR ' : ' ').'nombre = "pltcfg_'.$var.'"';
			}
			if (!empty($tmpcons)) {
				$cons = 'SELECT nombre,valor FROM _main WHERE '.$tmpcons;
				$cfgrs = $db->query($cons);
				if ($db->num_rows($cfgrs)) {
					$aPltSearch = array();
					$aPltVars = array();	// el valor indice corresponde a N variables de configuracion (vector valor)
					while($aTmp = $db->fetch_assoc($cfgrs)) {
						if (!in_array($aTmp['valor'],$aPltSearch)) {
							array_push($aPltSearch,$aTmp['valor']);
						}
						if (!is_array($aPltVars[$aTmp['valor']])) $aPltVars[$aTmp['valor']] = array();
						array_push($aPltVars[$aTmp['valor']],substr($aTmp['nombre'],7));
					}

					if (is_array($aPltSearch) AND sizeof($aPltSearch)) {
						$tmpcons = NULL;
						foreach ($aPltSearch as $plt) 
							$tmpcons .= ( (!empty($tmpcons)) ? ' OR ' : ' ' ).( (is_numeric($plt)) ? 'id_plantilla = '.$plt : 'nombre = "'.$plt.'"' );

						if (!empty($tmpcons)) {
							$cons = "SELECT id_plantilla,nombre,pre_code,post_code,arg_var FROM Plantillas WHERE ".$tmpcons;
							$rs = $db->query ($cons);
							if ($db->num_rows ($rs)) {
								while ($aPlt = $db->fetch_assoc($rs)) {
									if (is_array($aPltVars[$aPlt['id_plantilla']])) {
										$fld = 'id_plantilla';
									} elseif (is_array($aPltVars[$aPlt['nombre']])) {
										$fld = 'nombre';
									} else $fld = NULL;

									if (!empty($fld)) 
										while (sizeof($aPltVars[$aPlt[$fld]])) 
											$this->_aCfgPlts[array_shift($aPltVars[$aPlt[$fld]])] = $aPlt;
								}
							}
							$db->libera($rs);
						}
					}

				}
			}
		}

		// Obtener via aKrnConf (todo)
		// $this->configuracion['scripts_dir'] = $db->read_main_value ("scripts_dir");
		// if (empty($this->configuracion['scripts_dir'])) $this->configuracion['scripts_dir'] = $this->getFromKrn('scripts_path');
		// $this->configuracion['root_dir'] = $db->read_main_value ("doc_root");
		// if (empty($this->configuracion['root_dir'])) $this->configuracion['root_dir'] = $this->getFromKrn('doc_root');

		if ($BACKOFFICE) {
			$this->configuracion['def_secc'] = $this->getFromKrn('default_subsecc_bo');
		} else {
			$this->configuracion['def_secc'] = $this->getFromKrn('default_subsecc_fo');
		}

		if (!is_object($this->oMsgs)) $this->oMsgs = new IMessages();
		if (!empty($this->_aKrnConf['locale_path'])) $this->oMsgs->setPath($this->_aKrnConf['locale_path']);
		if (!empty($this->_aKrnConf['locale_kernmsgs'])) $this->oMsgs->addModule('IKernel',$this->_aKrnConf['locale_kernmsgs'],TRUE);

		// Cargando los posibles modulos de la aplicacion.
		$cons = 'SELECT '.
					'id_modulo as "id_modulo", '.
					'nombre as "nombre", '.
					'base as "es_base", '.
					'source as "src_file", '.
					'class as "class", '.
					'mask as "mascara" '.
					'FROM Modulos '.
					'WHERE activo = 1 '.
					'ORDER BY base desc;';
		$idrs = $db->query ($cons);
		$mascara = 0;
		if ($db->num_rows ($idrs)) 
			while ($aMod = $db->fetch_assoc($idrs)) {
				$idxm = (!empty($aMod['nombre']) ? $aMod['nombre'] : $aMod['id_modulo']);
				settype($aMod['mascara'],'int');
				$this->_aModulos[$idxm] = $aMod;
				$mascara |= $aMod['mascara'];
			}
		$db->libera($idrs);
		$this->_aModList['mascara'] = $mascara;

		// Cargando Los formatos por _tipo_ de dato:
		if ($this->_getKrnCfg('format_data')) {
			$cons = 'SELECT '.
						' nombre as "dato", longitud as "len", format_method as "format", '.
						'format_params as "format_params", parser_params as "parser_params", '.
						'parser_method as "parser", data_css "data_css", label_css as "label_css" '.
						'FROM Data_format_style ';
			$idrs = $db->query($cons);
			if ($db->num_rows($idrs)) 
				while ($aTmp = $db->fetch_assoc($idrs)) {
					if (!empty($aTmp['format_params'])) $aTmp['format_params'] = $this->_parseMethodParams($aTmp['format_params']);
					if (!empty($aTmp['parser_params'])) $aTmp['parser_params'] = $this->_parseMethodParams($aTmp['parser_params']);
					$this->_aDataFormats[$aTmp['dato']][( (is_numeric($aTmp['len'])) ? $aTmp['len'] : 0 )] = $aTmp;
				}
			$db->libera($idrs);
			// print_r($this->_aDataFormats);
		}

		return TRUE;
	}

	function _setIfaceList() {
		$oDb = $this->get_db('conf');

		/** Obtencion de Ifaces disponibles **/
		$cons = 'SELECT * FROM Tipos_iface';
		$tmprs = $oDb->query($cons);
		if ($oDb->num_rows($tmprs)) {
			while ($aTmp = $oDb->fetch_assoc($tmprs)) {
				$this->_aIfaces['iface'][$aTmp['id_tipo_iface']]['id'] = $aTmp['id_tipo_iface'];
				$this->_aIfaces['iface'][$aTmp['id_tipo_iface']]['nombre'] = $aTmp['nombre'];
				$this->_aIfaces['iface'][$aTmp['id_tipo_iface']]['nemonico'] = $aTmp['nemonico'];
				$this->_aIfaces['iface'][$aTmp['id_tipo_iface']]['path'] = $aTmp['path'];
				if (!empty($aTmp['method_name'])) {
					$this->_aIfaces['iface'][$aTmp['id_tipo_iface']]['method'] = $aTmp['method_name'];
					if (!empty($aTmp['method_params'])) 
						$this->_aIfaces['iface'][$aTmp['id_tipo_iface']]['method_params'] = $this->_parseMethodParams($aTmp['method_params']);
				} 
				if (!empty($aTmp['var_name'])) { 
					$this->_aIfaces['iface'][$aTmp['id_tipo_iface']]['var'] = $aTmp['var_name'];
				}
			}
		}
		$oDb->libera($tmprs);

		/** Obtencion de Idiomas disponibles **/
		$cons = 'SELECT * FROM Idiomas';
		$tmprs = $oDb->query($cons);
		if ($oDb->num_rows($tmprs)) {
			while ($aTmp = $oDb->fetch_assoc($tmprs)) {
				$this->_aIfaces['lang'][$aTmp['id_idioma']]['id'] = $aTmp['id_idioma'];
				$this->_aIfaces['lang'][$aTmp['id_idioma']]['nombre'] = $aTmp['nombre'];
				$this->_aIfaces['lang'][$aTmp['id_idioma']]['nemonico'] = $aTmp['nemonico'];
				$this->_aIfaces['lang'][$aTmp['id_idioma']]['path'] = $aTmp['path'];
				if (!empty($aTmp['locale_name'])) $this->_aIfaces['lang'][$aTmp['id_idioma']]['locale'] = $aTmp['locale_name'];

				if (!empty($aTmp['method_name'])) {
					$this->_aIfaces['lang'][$aTmp['id_idioma']]['method'] = $aTmp['method_name'];
					if (!empty($aTmp['method_params'])) 
						$this->_aIfaces['lang'][$aTmp['id_idioma']]['method_params'] = $this->_parseMethodParams($aTmp['method_params']);
				} elseif (!empty($aTmp['var_name'])) { 
					$this->_aIfaces['lang'][$aTmp['id_idioma']]['var'] = $aTmp['var_name'];
				}
			}
		}
		$oDb->libera($tmprs);

		/** Obtencion de Temas disponibles **/
		$cons = 'SELECT * FROM Temas';
		$tmprs = $oDb->query($cons);
		if ($oDb->num_rows($tmprs)) {
			while ($aTmp = $oDb->fetch_assoc($tmprs)) {
				$this->_aIfaces['tema'][$aTmp['id_tema']]['id'] = $aTmp['id_tema'];
				$this->_aIfaces['tema'][$aTmp['id_tema']]['nombre'] = $aTmp['nombre'];
				$this->_aIfaces['tema'][$aTmp['id_tema']]['nemonico'] = $aTmp['nemonico'];
				$this->_aIfaces['tema'][$aTmp['id_tema']]['style_sheet'] = $aTmp['style_sheet'];

				if (!empty($aTmp['method_name'])) {
					$this->_aIfaces['tema'][$aTmp['id_tema']]['method'] = $aTmp['method_name'];
					if (!empty($aTmp['method_params'])) 
						$this->_aIfaces['tema'][$aTmp['id_tema']]['method_params'] = $this->_parseMethodParams($aTmp['method_params']);
				} elseif (!empty($aTmp['var_name'])) { 
					$this->_aIfaces['tema'][$aTmp['id_tema']]['var'] = $aTmp['var_name'];
				}
			}
		}
		$oDb->libera($tmprs);

	}

	function _fillIfaceWithDefaults() {
		// Si no hay un Iface definido, buscamos el predefinido del sistemal.
		$aI = $this->get_iface();
		$bSet = FALSE;
		// Si falta algun parametro que afecte a rutas...
		if (!is_array($aI) OR (!sizeof($aI['iface'])) OR (!sizeof($aI['lang'])) ) {
			$def_lng = $this->_getKrnCfg('default_lang');
			$def_ifc = $this->_getKrnCfg('default_iface');
			$def_thm = $this->_getKrnCfg('default_theme');
			if (!empty($def_lng) OR !empty($def_ifc) OR !empty($def_thm)) {
				if ($this->debug) debug("_fillIfaceWithDefaults(); CHeking ifaces ...");
				$aTmp = array();
				// Metemos en un array temporal el iface ya obtenido.
				if (is_numeric($aI['lang']['id'])) $aTmp['lang'] = $aI['lang']['id'];
				if (is_numeric($aI['iface']['id'])) $aTmp['iface'] = $aI['iface']['id'];
				if (is_numeric($aI['theme']['id'])) $aTmp['theme'] = $aI['theme']['id'];
				// Si falta algun aspecto del iface en el que hemos obtenido, lo sustiumos por su valor por defecto.
				if (!is_numeric($aTmp['lang']) AND !empty($def_lng)) {
					$bSet = TRUE;
					$aTmp['lang'] = $def_lng;
				}
				if (!is_numeric($aTmp['iface']) AND !empty($def_ifc)) {
					$bSet = TRUE;
					$aTmp['iface'] = $def_ifc;
				}
				if (!is_numeric($aTmp['theme']) AND !empty($def_thm)) {
					$bSet = TRUE;
					$aTmp['theme'] = $def_thm;
				}
				if ($bSet) {
					if ($this->debug) debug("_fillIfaceWithDefaults(); Setting def ifaces ...");
					$this->set_iface($aTmp);
				}
			}
		}

		$aIface = $this->get_iface();
		if (!empty($aIface['lang']['locale'])) {
			// debug("Estableciendo locale de idioma ... ".$this->_aIfaces['lang'][$aIface['lang']]['locale']);
			$lcstr = $aIface['lang']['locale'];
		} else {
			$lcstr = $this->_getKrnCfg('locale_sysdefault');
			// debug("Buscando locale por defecto ... ".$lcstr);
		}
		if (!empty($lcstr)) {
			// debug("Estableciendo local .. $lcstr");
			// setlocale(LC_ALL,$lcstr);
			// print_r(localeconv());
		}
		return !$bSet;
	}

	/**
	* Obtenemos los parametros de configuracion del kernel.
	**/
	function _getKrnCfg ($var = NULL) {
		if (!is_array ($this->_aKrnConf) OR !sizeof ($this->_aKrnConf)) return NULL;
		if (isset($var) AND !empty($var)) {
			return $this->_aKrnConf[$var];
		} else return $this->_aKrnConf;
	}

	function getFromKrn($var = NULL) {
		if (!is_array ($this->_aKrnConf) OR !sizeof ($this->_aKrnConf)) return NULL;
		if (isset($var) AND (!empty($var) OR is_numeric($var)) ) {
			return $this->_aKrnConf[$var];
		} else return NULL;
	}

	function getFromConf($var = NULL) {
		if (!is_array ($this->configuracion) OR !sizeof ($this->configuracion)) return NULL;
		if (isset($var) AND !empty($var)) {
			return $this->configuracion[$var];
		} else return $this->configuracion;
	}

	function getCfgPlt($var = NULL) {
		if (!is_array ($this->_aCfgPlts) OR !sizeof ($this->_aCfgPlts)) return NULL;
		if (isset($var) AND !empty($var)) {
			return $this->_aCfgPlts[$var];
		} else return $this->_aCfgPlts;
	}

		  /**
        * Poner tablas de configuracion
        * @param       $tabla vale pa algo ???
        */
	function _set_conf_tbs ($tabla = "") {
		// global $oDb;
		$oDb = &$this->get_db('conf');
		$this->tb_secciones = $oDb->read_main_value ("tb_secciones");
		$this->tb_plantillas = $oDb->read_main_value ("tb_plantillas");
		$this->tb_sub_secc = $oDb->read_main_value ("tb_sub_secc");
		$this->tb_sec_subsecc = $oDb->read_main_value ("tb_sec_subsecc");
		$this->tb_sub_plts = $oDb->read_main_value ("tb_sub_plts");
		$this->tb_modulos = $oDb->read_main_value ("tb_modulos");
		$this->tb_modulos_subsecc = $oDb->read_main_value ("tb_modulos_subsecc");

		return;
	}

		  /**
        *Coger configuracion de tablas
        *"secciones"                             => $this->tb_secciones,
        *"sub_secciones"                         => $this->tb_sub_secc,
        *"sec_subsecc"                           => $this->tb_sec_subsecc,
        *"subsecc_plantillas"                    => $this->tb_sub_plts,
        *"plantillas"                            => $this->tb_plantillas
        *      @return  un array asociativo con los nombres de las tablas
        */
	function get_conf_tbs () {
		$oDb = $this->get_db ('conf');
		return array ("secciones" => $this->tb_secciones,
						  "sub_secciones" => $this->tb_sub_secc,
						  "sec_subsecc" => $this->tb_sec_subsecc,
						  "subsecc_plantillas" => $this->tb_sub_plts,
						  "plantillas" => $this->tb_plantillas
			);
	}

	/**
	  * FixMe: Esta funcion se llama justo antes de unserializar la sesion. Lo que esta habra de hacer es incluir y unserializar los modulos
	  *   y sus variables. Para ello, no se puede dejar al php que lo haga, dado que logicamente lo hace en orden ascentente por profundidad, con lo cual,
	  *   al ser esta la ultima clase que se despierta, no puede incluir los scripts necesarios para despertar las clases que le cuelgan.
	  *		En primera instancia se me ocurre como solucion que el metodo cerrar, despues de cerrar() sus clases, las serialice el mismo en un string y luego 
	  *	las guarde para recuperarlas con el __wakeup() e iniciarlas con el load_modules(). Las ventajas que esta solucion icorpora es que permite conocer
	  *	que variables/clases -que suele ser lo mas pesado- pertenecen a que sesiones, y que permite una carga selectiva de clases por subseccion, de tarl forma que 
	  *	las instancias que no se necesiten en una determinada subseccion no se cargen.
	  *		Otra posibilidad es tener una clase padre al mas purto estilo 'Serializable' de java, de la cual han de heredar todas las intancias que quieran 
	  *	ser serializables por el kernel. Este 'soporte', caso de ser posible, seria mas ligero que andar haciendo comprobaciones para las clases. Esta dudo 
	  *	que sea posible, a no ser que el wake_up del padre se ejecute antes que el del hijo, y se puede hacer el include en se momento.
	  **/
	function __wakeup () {
		// debug("wakeup de sesion...".$this->obj_var_name);
		if (is_array($this->_aModulos))
			foreach ($this->_aModulos as $name => $aMod) {
				// if ($this->debug & DBUG_MODS) debug("__wakeup(): marcando $name... $aMod[src_file]");
				// FIXME: serializar o incluir los modulos antes?
				// FIXME: Soporte de modulos todavia incompleto.
				// include_inm("modulos/".$this->_aModulos[$name]['src_file'].'.inc');
				$this->_aModulos[$name]['incluido'] = 1;
			}

		return 1;					  // Fixme: El soporte de modulos no funciona correctamente. (inclusion de las clases)
	}

	/** soporte email **/
	function _setStdOutMod($modname) {
		if (!empty($modname)) {
			$modname = strtolower($modname);
			switch($modname) {
				case 'email':
					$email = $this->fetchVar('_email','POST');
					$subj = $this->fetchVar('_subject','POST');
					$this->set_var('__output__email',$email,'INMED');
					if (!empty($subj)) $this->set_var('__output__email__subject',$subj,'INMED');
					$this->set_var('__output__browser',TRUE,'INMED');
					$this->set_var('__output__handle','emailoutput','INMED');
					$this->set_var('__output__finish','emailsender','INMED');
					$this->set_var('__output__name','email','INMED');
					$mod = 'email';
			}
		}

		if (!empty($mod)) $this->set_var('__output__',$mod,'INMED');
		else $this->unset_var('__output__');
	}

	/** 
	  * Metodo encargado de informar el formato de salida de datos:
	  *
	  * @return		-	[bBrowser]	=> bool		Si la salida tambien ha de mandarse al navegador.
	  *					[ModName]	=> string	Nombre de modulo de salida.
	  *					[handler]	=> string	Nombre de la funcion que maneja la salida.
	  *					[finish]		=> string	Nombre de funcion de cierre de salida.
	  **/
	function _getStdOutMod($modname = NULL) {
		$n = $this->get_var('__output__');
		$aRetVal = NULL;
		if (!empty($n)) {
			$aRetVal['bBrowser'] = (bool)$this->get_var('__output__browser');
			$aRetVal['ModName'] = $this->get_var('__output__name');
			$aRetVal['handler'] = $this->get_var('__output__handle');
			$aRetVal['finish'] = $this->get_var('__output__finish');
		}
		return $aRetVal;
	}
  /** **/


	/*
	 * Init nos va a buscar en la db nuestra seccion 
	 */
	function init ($seccion) {
		global $force_;			  // Forzamos la recarga de todas las plantillas de subseccion?
		// Definiciones de mascaras de control de Debug:
		// debug("wolSession::init($seccion) ");

		$this->debug = DBUG_DB | DBUG_INC ;
		$this->debug = (DBUG_INC | DBUG_VARS) ;
		$this->debug = (DBUG_DB | DBUG_INC) ;
		$this->debug |= (DBUG_MODS ) ;
		$this->debug |= (DBUG_VARS | DBUG_INC);
		$this->debug = (DBUG_VARS );
		$this->debug = 0;

				/**** Conectamos los objetos wolDB que tenemos almacenados ****/
		$this->conectar_dbs ('conf');

				/**** Cargamos los Modulos Internos *****/
		// $this->load_internal_modules();

				/*** comprobaciones de secciones y subsecciones ****/
		if (empty ($this->tb_secciones)) {
			debug("Que no existe tb_secciones!! ");
			$this->perror(1,'KERNEL_CONF','Error interno de configuracion, Leaks en las sesiones');
			return 0;
		}

		/** soporte email **/
		$stdout = $this->fetchVar('__stdout__','GET');
		if (!empty($stdout)) $this->_setStdOutMod($stdout);
		/** **/

		$this->initSection($seccion);

		/**** Conectamos la conexion de Datos *****/
		$this->conectar_dbs ("data");
		$this->activate_db ('conf');

		$this->set_var('_krn_ss_name',$this->get_subsecc_name(),'INMED');
		$this->set_var('_krn_old_ss_name',$this->get_old_subsecc_name(),'INMED');
		$this->set_var('_krn_ss_querystring',$this->get_subsecc_querystring(),'INMED');

		/** Miramos a ver los accesos para esta seccion ** (off) */

		if (!is_object($this->Access)) {
			// Reemplazar obj_var_name por App_Name cuando estos coincidan.
			$this->Access = new wolAV ($this->obj_var_name);
		}

		$this->detect_ifaces();

		if (!$this->Access->init ($this)) {
			$this->activate_db ('data');
			$this->_fillIfaceWithDefaults();
			$this->set_pltdir();

			if ((int)$this->fetchVar('logout','GET') AND session_id()) {
				$oDbCfg = &$this->get_db('conf');
				$oDbCfg->unbuffered_query('DELETE FROM Users_sessions WHERE sessid = "'.session_id().'" AND app_name = "'.$this->App_Name.'" ');
			}
			return 0;
		}

		$oUsr = $this->get_authed_user();
		if (is_a($oUsr,'wolUsr')) {
			// debug("Tenemos usuario reciente(".$oUsr->recent_login.")? y recoveredSession(".(bool)$this->getFromKrn('recovered_session').")? Sess: ".session_id());
			$id_usr = $this->get_user();
			$oDbCfg = &$this->get_db('conf');
			if (!$this->getFromKrn('recovered_session') AND $oUsr->recent_login) {
				// debug("<b>Sesion no recuperada</b>, intentandolo con el id_usr = ".$this->get_user());
				$cons = 'SELECT valor,sessid FROM Users_sessions WHERE id_usr = "'.$this->get_user().'" AND app_name = "'.$this->App_Name.
							'" ORDER BY modificacion desc LIMIT 1';
				$srs = $oDbCfg->query($cons);
				// debug("cons: $cons ");
				if ($oDbCfg->num_rows($srs)) {
					$aTmp = $oDbCfg->fetch_row($srs);
					if (!empty($aTmp[0])) {
						$new_sid = $aTmp[1];
						session_write_close();
						session_id($new_sid);
						session_start();

						//Fix PHP5 $this = unserialize($aTmp[0]);
						$GLOBALS[$this->App_Name] = unserialize($aTmp[0]);
						$this->_aKrnConf['recovered_session'] = true;
						$this->set_db('conf',&$oDbCfg,true);
						$oDbCfg->unbuffered_query('UPDATE Users_sessions SET modificacion = NOW() WHERE id_usr="'.$id_usr.'" AND sessid="'.$new_sid.
															'" AND app_name = "'.$this->App_Name.'" ');
						if (!empty($_SESSION['session_expiretime'])) {
							$oDbCfg->unbuffered_query('DELETE FROM Users_sessions WHERE id_usr = '.$id_usr.
										' AND modificacion < DATE_SUB(NOW(),INTERVAL '.$_SESSION['session_expiretime'].' HOUR) ');
						}
						if (!empty($seccion)) $this->initSection($seccion);
						// debug("Recuperada session $new_sid ");
					}
				}
			} elseif ( $this->fetchVar('__recover_session','GET') ) {
				$new_sid = $this->fetchVar('__recover_session','GET');
				$old_sid = session_id();
				if ($new_sid != $old_sid) {
					$cons = 'SELECT valor FROM Users_sessions WHERE id_usr = "'.$id_usr.'" AND sessid = "'.$new_sid.'" AND app_name = "'.$this->App_Name.'" ';
					$srs = $oDbCfg->query($cons);
					if ($oDbCfg->num_rows($srs)) {
						$aTmp = $oDbCfg->fetch_row($srs);
						if (!empty($aTmp[0])) {
							session_write_close();
							session_id($new_sid);
							session_start();

							//Fix PHP5 $this = unserialize($aTmp[0]);
							$GLOBALS[$this->App_Name] = unserialize($aTmp[0]);
							$this->_aKrnConf['recovered_session'] = true;
							$this->set_db('conf',&$oDbCfg,true);
							$oDbCfg->unbuffered_query('UPDATE Users_sessions SET modificacion = NOW() WHERE id_usr = "'.$id_usr.'" AND sessid = "'.$new_sid.
																'" AND app_name = "'.$this->App_Name.'" ');
							if (!empty($seccion)) $this->initSection($seccion);
						}
					}
				}
			} elseif ( (bool)$this->fetchVar('__create_session','GET') AND is_numeric($id_usr) AND !empty($id_usr) ) {
				// $old_sid = session_id();
				$rval = (int)session_regenerate_id();
				// $new_sid = session_id();
				$this->_aKrnConf['recovered_session'] = false;
				// debug("Creando sesion nueva ... de $old_sid a $new_sid retval: $rval ");
			}
		} else {
			if (!$this->getFromKrn('recovered_session') AND !empty($_SESSION['session_expiretime'])) {
				$oDbCfg = &$this->get_db('conf');
				$oDbCfg->unbuffered_query('DELETE FROM Users_sessions WHERE modificacion < DATE_SUB(NOW(),INTERVAL '.$_SESSION['session_expiretime'].' HOUR) ');
			}
		}

		if (is_array($_SESSION['post_before_login']) AND sizeof($_SESSION['post_before_login'])) {
			$_POST = $_SESSION['post_before_login'];
			unset($_SESSION['post_before_login']);
		}

		// Algun modulo puede necesitar alguna DB, las conectamos todas.
		$this->conectar_dbs("el_resto");

		$modmask = $this->_aModList['mascara'];
		if (is_numeric($modmask) and !empty($modmask) and !($modmask & $this->_aSeccion['module_mask']) ) {
			$ss = $this->getFromKrn('nomodule_subsecc');
			$this->reset_plts();
			$this->set_idsecc($ss,true);
			$this->set_plts();
		}

		/*
		 * Este metodo nos va a establecer la ruta del iface que esta activo.
		 */
		$this->_fillIfaceWithDefaults();
		$this->set_pltdir();

		// Si se ha producido algun error (Al cargar los modulos por ejemplo)..
		if ($this->oMsgs->haveCode(IM_FATALERROR)) {
			$pltpii = $this->get_plt_name(0);
			if (!empty($pltpii)) {
				$this->change_plt_precode($pltpii,
					$this->_aCfgPlts['err_full']['nombre'],
					$this->_aCfgPlts['err_full']['pre_code'],
					$this->_aCfgPlts['err_full']['post_code'],
					$this->_aCfgPlts['err_full']['arg_var']
						);
				$this->perror_link('LOGOUT');
			}
		}

		/** Incluimos los includes **/
		$this->includes();

					  /********** MODULOS *************/

		/** Inicializamos el buscador (si procede) */
		if (!is_object($this->b_activa)) {
			$this->b_activa = new wol_search ($this->App_Name);
		}
		$this->hay_b = $this->b_activa->init(&$this);
		// debug("!ojo que buscador devuelve ".$this->hay_b."<BR>\n");

				/** Inicializamos los Menus *
				if (!is_object($this->menu))
												 $this->menu = new wol_menu($this->App_Name);
				$this->hay_menu = $this->menu->init($this);
				*/
		$this->hay_menu = 0;

				/** Inicializamos las Notificaciones **
				if (!is_object($this->notifica))
												 $this->notifica = new wol_notifica($this->App_Name);
				$this->hay_noti = $this->notifica->init($this);
				/* */

		// Soporte de Modulos:
		$this->load_modules();

		if ($this->hay_b) $this->b_activa->doSearch();

				/**** Conectamos la conexion de Datos *****/
		$this->activate_db ('data');

		return TRUE;
	}

	function initSection($seccion) {
		if (empty ($this->seccion)) {
			/*
			 * Si ta vacia la seccion, acabamos de entrar y por tanto entramos por la seccion por defecto. 
			 */
			if ($this->debug & DBUG_MODS)
				debug ("Seccion por defecto: $this->def_secc($seccion) - $this->seccion");
			if (empty ($seccion))
				$seccion = $this->def_secc;

			// Acuerdate de Traerte el parche de 'acceso directo a subsecciones' de postalfree variable en config.php
			$this->set_idsecc ($seccion, TRUE);

			$this->set_plts();
			$this->bRecarga = 0;
			//$this->hay_b=0;
			//salida("Acabas de entrar en $seccion<BR>\n");
		} elseif (empty ($seccion) OR ! isset ($seccion)) {
			/*
			 * Si la seccion esta vacia (pero this->seccion no) entonces Estamos paginando(recargando estando un modulo en marcha) y 
			 * se conservan las plts 
			 */
			if ($this->debug & DBUG_MODS)
				debug ("Param-Seccion Vacia. Busqueda : ".(($this->hay_b) ? "Si" : "No"));

			// old_secc_name nuevo. documentar
			if (!empty($this->old_secc_name)) {
				if (!$this->kick_the_baby ()) {
					// Si no hay busqueda, porque recarga la anterior?
					$seccion = $this->old_secc_name;
					$this->set_idsecc($seccion);
					//salida("renice - Old_Secc : ".$this->old_secc_name."<BR>\n" );
					// unset($this->old_secc_name);
				} else {
					$seccion = $this->seccion;
					$this->set_idsecc ($seccion);
				}

				$this->reset_plts ();
				$this->set_plts ();
			} else {
				//salida("Establecemos old_secc_name (".$this->seccion.")");
				$seccion = $this->seccion;
			}
			$this->bRecarga = 2;
			if ($this->debug & DBUG_MODS)
				debug ("Recarga de Modulo ($this->bRecarga) o Paginado ");
		} elseif (!strcmp ($seccion, $this->seccion)) {
			/*
			 * Si seccion y this->seccion son =, entonces se ha producido una recarga de la pagina. conservamos las plts * -ojo- 
			 */
			if ($this->debug & DBUG_MODS)
				debug ("Recarga(1) de subseccion");
			$this->bRecarga = 1;
			$this->set_idsecc ($seccion);
			// $this->set_pltdir();
			// unset($this->plantillas);
			if ($force_) {
				// unset($this->plantillas);
				$this->set_plts ();
			}
			/*
			 * tb limpiamos las buskedas * if ($this->debug & DBUG_MODS) debug("Unset de buskedas.(no se pk)"); $this->hay_b = 0;
			 * $this->b_activa = NULL; unset($this->b_activa); /** *
			 */
			// $this->hay_b = 0;
			//salida("Has recargao... a k si!<BR>\n");
		} else {
			/*
			 * Unico caso k nos keda, cambio de seccion. Limpiamos plts 
			 */
			if ($this->debug & DBUG_MODS)
				debug ("Cambiaaaaaando de Seccion (act:$seccion -> old:$this->seccion - $this->id_secc)");
			$this->reset_plts ();
			$this->bRecarga = 0;
			$this->unset_vars ("SUBSECCION");

			$this->set_idsecc ($seccion);
			$this->set_plts ();

		}

		return true;
	}

					 /********** Comprobaciones de init() ***************/

	function detectIfaceForBrowser($iface) {
		//debug("Detecting .... ");
		switch ($iface) {
			case 'pda':
				if (strstr($_SERVER['HTTP_USER_AGENT'],'Windows CE')) {
					$rval = true;
				} else $rval = false;
				break;
			default:
				$rval = false;
				break;
		}

		if (!$rval) {
			$oS = $GLOBALS[$GLOBALS['APP_NAME']];
			$ifz = $oS->fetchVar('iface','GET POST');
			if ($iface == $ifz) $rval = true;
		}

		return $rval;
	}

	/*
	 * pandora 
	 */
	function detect_ifaces() {

		$retval = false;
		/** Detectando Iface **/
		if (!isset($this->_aActiveIface['iface'])) {
			foreach ($this->_aIfaces['iface'] as $aIface) {
				if (!empty($aIface['var']) AND !empty($aIface['nemonico'])) {
					$val = $this->fetchVar($aIface['var'],'GET');
					if (empty($val)) $val = $this->fetchVar($aIface['var'],'POST');
					if (!strcasecmp($val,$aIface['nemonico'])) {
						$aI['iface'] = $aIface['id'];
						$retval = true;
						break;
					}
				} 
				if (!empty($aIface['method'])) {
					$aParams = array();
					if (!empty($aIface['method_params']) and is_array($aIface['method_params']) and sizeof($aIface['method_params']))
						$aParams = $this->_fetchMethodParams($aIface['method_params']);
					array_unshift($aParams,$aIface['nemonico']);

					$aF = &$this->_getCallBackMethod($aIface['method']);
					if ($aF and @call_user_func_array(&$aF['call'],$aParams)) {
						$aI['iface'] = $aIface['id'];
						$retval = true;
						break;
					}
				}
			}
		}

		/** Detectando Idioma **/
		if (!isset($this->_aActiveIface['lang'])) {
			foreach ($this->_aIfaces['lang'] as $aLang) {
				if (!empty($aLang['var']) AND !empty($aLang['nemonico'])) {
					$val = $this->fetchVar($aLang['var'],'GET');
					if (empty($val)) $val = $this->fetchVar($aLang['var'],'POST');

					if (!strcasecmp($val,$aLang['nemonico'])) {
						$aI['lang'] = $aLang['id'];
						$retval = TRUE;
						break;
					}
				} elseif (!empty($aLang['method'])) {
					$aParams = array();
					if (!empty($aLang['method_params']) and is_array($aLang['method_params']) and sizeof($aLang['method_params']))
						$aParams = $this->_fetchMethodParams($aLang['method_params']);
					array_unshift($aParams,$aLang['nemonico']);

					$aF = &$this->_getCallBackMethod($aLang['method']);
					if ($aF and @call_user_func_array(&$aF['call'],$aParams)) {
						$aI['lang'] = $aLang['id'];
						$retval = true;
						break;
					}
				}
			}
		}

		/** Detectando Tema **/
		foreach ($this->_aIfaces['tema'] as $aTema) {
			if (!empty($aTema['var']) AND !empty($aTema['nemonico'])) {
				$val = $this->fetchVar($aTema['var'],'GET');
				if (empty($val)) $val = $this->fetchVar($aTema['var'],'POST');
				if (!strcasecmp($val,$aTema['nemonico'])) {
					$aI['tema'] = $aTema['id'];
					$retval = TRUE;
					break;
				}
			} elseif (!empty($aTema['method'])) {
				$aParams = array();
				if (!empty($aTema['method_params']) and is_array($aTema['method_params']) and sizeof($aTema['method_params']))
					$aParams = $this->_fetchMethodParams($aTema['method_params']);
				array_unshift($aParams,$aTema['nemonico']);

				$aF = &$this->_getCallBackMethod($aTema['method']);
				if ($aF and @call_user_func_array(&$aF['call'],$aParams)) {
					$aI['tema'] = $aTema['id'];
					$retval = true;
					break;
				}
			}
		}

		if (is_array($aI) AND sizeof($aI)) $this->set_iface($aI);

		return $retval;
	}

	/**
	  * Establece el iface activo. via un vector con indice 'iface','lang','tema' y valor numerico o nemonico
	  **/
	function set_iface($aIface = array()) {
		if (!sizeof($aIface) OR !is_array($aIface)) return 0;

		foreach ($aIface as $type => $value) {
			if (!empty($value) AND !is_numeric($value)) {
				if (is_array($this->_aIfaces[$type]) AND sizeof($this->_aIfaces[$type])) {
					$tmp = NULL;
					foreach ($this->_aIfaces[$type] as $id => $aIn) {
						if ($aIn['nemonico'] == $value) {
							$tmp = $id;
							break;
						}
					}
					$aIface[$type] = $tmp;
				}
			}
		}

		if (is_numeric($aIface['iface']) AND is_array($this->_aIfaces['iface'][$aIface['iface']])) {
			$this->_aActiveIface['iface'] = $aIface['iface'];
		}
		if (is_numeric($aIface['lang']) AND is_array($this->_aIfaces['lang'][$aIface['lang']])) {
			$this->_aActiveIface['lang'] = $aIface['lang'];

			if (!is_object($this->oMsgs)) {
				$this->oMsgs = new IMessages();
				//TODO: Anyadir mensaje de error: perdida de clase de msgs.
			}
			$this->oMsgs->setLocale($this->_aIfaces['lang'][$aIface['lang']]['nemonico']);
		}
		if (is_numeric($aIface['tema']) AND is_array($this->_aIfaces['tema'][$aIface['tema']])) {
			$this->_aActiveIface['tema'] = $aIface['tema'];
		}

	}

	function get_iface($aIDs = NULL) {
		if (!is_array($aIDs) OR !sizeof($aIDs)) 
			$aIDs = $this->_aActiveIface;

		foreach ($aIDs as $type => $value) {
			if (!empty($value) AND !is_numeric($value)) {
				if (is_array($this->_aIfaces[$type]) AND sizeof($this->_aIfaces[$type])) {
					$tmp = NULL;
					foreach ($this->_aIfaces[$type] as $id => $aIn) {
						if ($aIn['nemonico'] == $value) {
							$tmp = $id;
							break;
						}
					}
					$aIDs[$type] = $tmp;
				}
			}
		}

		if (is_array( $this->_aIfaces['iface'][$aIDs['iface']]) AND sizeof( $this->_aIfaces['iface'][$aIDs['iface']]))
			$aI['iface'] =  $this->_aIfaces['iface'][$aIDs['iface']];
		if (is_array( $this->_aIfaces['lang'][$aIDs['lang']]) AND sizeof( $this->_aIfaces['lang'][$aIDs['lang']]))
			$aI['lang'] =  $this->_aIfaces['lang'][$aIDs['lang']];
		if (is_array( $this->_aIfaces['tema'][$aIDs['tema']]) AND sizeof( $this->_aIfaces['tema'][$aIDs['tema']]))
			$aI['tema'] =  $this->_aIfaces['tema'][$aIDs['tema']];
		return $aI;
	}

	 /**
	 *  Coger el usuario activo
	 *  @return  identificador del usuario activo (como no)
	 */
	function get_user () {
		if (!is_a($this->Access,'WolAV')) return NULL;
		$a = $this->Access->oUsr->id_usr;
		// debug("usr =". $a);
		return $a;
	}

	function get_authed_user () {
		if (!is_a($this->Access,'WolAV')) return NULL;
		return $this->Access->oUsr;
	}

			/**
         * nos dice si seguimos en esta seccion o cambiamos
         * Cuando la variable seccion no esta establecida
         * @return $this->hay_b
         */
	function kick_the_baby () {
		return $this->hay_b;
	}
	
	function haveSearch() {
		return $this->hay_b;
	}

	function &getSearch() {
		return $this->b_activa;
	}


		  /** 
			 * Carga la configuracion de los modulos.
			 **/
	function load_modules () {	  // Fixme: Documentar estos metodos.
		if ($this->debug & DBUG_MODS) debug ("load_modules() ...");

		if (is_array($this->_aModList) and sizeof($this->_aModList)) 
			foreach (array_keys($this->_aModList) as $modname) 
				if (method_exists($this->_aModList[$modname],'init')) $this->_aModList[$modname]->init($this);

		if (is_array($this->_aModulos) and sizeof($this->_aModulos))
			foreach ($this->_aModulos as $idxm => $aMod) {
				if ($this->debug & DBUG_MODS)
					debug ("load_modules( Incluido $aMod[nombre] - $aMod[class] ($aMod[src_file]) ) ...");
				// Aqui se deberia comprobar si es persistente o no. Actualmente se toman todos como persistentes.
				if (!(int) $this->_aModulos[$idxm]['incluido']) {
					//TODO: Actualmente no esta soportada la feature de inclusion de modulos a causa
					//	del comportamiento de la sesion al intentar poblar una estructura/clas no incluida todavia:
					// include_inm ("modulos/".$this->_aModulos[$idxm]['src_file'].'.inc');

					$this->_aModulos[$idxm]['incluido'] = 1;
				}
				if (!$this->oMsgs->getModuleInfo($aMod['nombre'])) {
					// Anyadimos el fichero de mensajes.
					$this->oMsgs->addModule($aMod['nombre'],$this->_aModulos[$idxm]['src_file'].'.lm',TRUE);
				}
			}

		if (is_array($this->_aClasses))
			foreach ($this->_aClasses as $var_name => $aCont) {
				if ($this->debug & DBUG_MODS) debug ("init de $var_name ... ");
				if (is_object($this->_aClasses[$var_name][0]))
					$this->_aClasses[$var_name][0]->init();
				// print_r($this->_aClasses[$var_name][0]);
			}
		// debug("comprobacion extra...");
		// $this->unload_modules();

		/** Antes de Renderizar, Miramos si hay modulos que activar **/
		// Primero obtenemos las posibles acciones de esta SS
		$this->_GetActionBySS($this->get_subsecc_name());
		$ssmask = $this->_aSeccion['module_mask'];
		if (is_numeric($ssmask) and !empty($ssmask) and is_array($this->_aModulos) and sizeof($this->_aModulos)) {
			foreach (array_keys($this->_aModulos) as $modname) {
				if ( ($this->_aModulos[$modname]['mascara'] & $ssmask) and !empty($this->_aModulos[$modname]['class'])) {
					if (!is_a($this->_aModList[$modname],$this->_aModulos[$modname]['class'])) {
						$this->_aModList[$modname] = new $this->_aModulos[$modname]['class'](&$this,$modname);
					} else $this->_aModList[$modname]->init();
					if (method_exists($this->_aModList[$modname],'SectionStart')) {
						if ($this->_aModList[$modname]->SectionStart()) {
							if (!is_array($this->_aActiveModules)) $this->_aActiveModules = array();
							array_push($this->_aActiveModules,$modname);
						}
					}
				}
			}
		}

		if (is_array($this->aData) and sizeof($this->aData))
			foreach (array_keys($this->aData) as $varname)
				if (is_a($this->aData[$varname][0],'inmersaSerialize'))
					$this->aData[$varname][0]->init();

		return true;
	}

	/***
		* Prepara los modulos para ser Guardados en Sesion.
		***/
	function unload_modules () {
		if ($this->debug & DBUG_MODS)
			debug ("unload_modules() ...");

		if (is_array($this->_aModList) and sizeof($this->_aModList)) 
			foreach (array_keys($this->_aModList) as $modname) 
				if (method_exists($this->_aModList[$modname],'cerrar')) $this->_aModList[$modname]->cerrar();

		if (is_array ($this->_aClasses))
			foreach ($this->_aClasses as $var_name => $aCont) {
				if ($this->debug & DBUG_MODS)
					debug ("unload_modules($var_name $aCont[0]) ... (nada)");
				if (is_object ($this->_aClasses[$var_name][0])) {
					if ($this->debug & DBUG_MODS) debug("disparando cierre de $var_name ");
					$this->_aClasses[$var_name][0]->cerrar();
				}
			} 
		else if ($this->debug & DBUG_MODS)
			debug ("No hay NINGUNA clase de modulo");
		if (is_array ($this->_aModulos))
			foreach ($this->_aModulos as $mod => $aVal) {
				$this->_aModulos[$mod]['incluido'] = 0;
				if ($this->debug & DBUG_MODS) debug("unload_module($mod)::incluido = 0");
			}

		if (is_array($this->aData) and sizeof($this->aData))
			foreach (array_keys($this->aData) as $varname)
				if (is_a($this->aData[$varname][0],'inmersaSerialize'))
					$this->aData[$varname][0]->cerrar();

	}

	/***
	  * Devuelve TRUE si la clase indicada pertenece a una clase de modulo.
	  **/
	function check_class_module ($class_name = NULL) {
		if (empty ($class_name))
			return FALSE;
		if (!class_exists ($class_name))
			return FALSE;
		$retval = FALSE;
		if (is_array ($this->_aModulos))
			foreach ($this->_aModulos as $nombre => $aMod)
				if (!strcasecmp ($aMod['class'], $class_name)) {
					$retval = TRUE;
					break;
				}
		if ($this->debug & DBUG_MODS)
			debug ("check_class_module($class_name) Found ? = ".(($retval) ? "Si" : "No"));
		return $retval;
	}


	/********** RUTAS y PATHS *********************/

		  /**
        * Hacemos los include propio de esta seccion
        */
	function includes () {

								 /** Hacemos los include propio de esta seccion **/
		$inc = $this->get_include ();
		if (!empty ($inc)) {
			// $tmp = $this->get_doc_root()."scripts/".$inc;
			$tmp = $this->get_script_dir ();
			$tmp .= $inc;
			if ($this->debug & DBUG_INC)
				debug ("include-> $tmp");
			include_inm ($tmp);
		}
	}

	/**
   *      Coger el directorio relativo donde se encuentran los scripts
   *      @return $this->script_dir
   */
	function get_script_dir () {
		// return $this->script_dir;
		return $this->getFromKrn('scripts_path');
	}

	/**
   *      establecer el directorio relativo donde se encuentran los scripts
   *      @return BOOL
   */
	function set_script_dir ($path = NULL) {
		if (!$path) return 0;
		// $this->script_dir = $path;
		debug("set_script_dir ($path) ");
		$this->_aKrnConf['scripts_path'] = $path;
		return 1;
	}

	/**
   *      Coger include
   *      @return $this->include
   */
	function get_include () {
		return $this->include;
	}

	/**
   *      Coger directorio raiz
   *      @return  un string con el nombre del directorio raiz
   */
	function get_doc_root () {
		return $this->getFromKrn('doc_root');
	}

	/**
   *      Coger directorio de imagenes
   *      @return  un string con el nombre relativo del directorio de imagenes
   */
	function get_img_path () {
		return $this->img_dir;
	}

	/**
   * Introduce el path de las plantilas
   * TODO: k sea a la db-conf
   * @param $path ruta , sin path lo va a buscar a la db.
   */
	function set_pltdir ($path = "") {
		if (!empty ($path))
			$this->plt_dir = $path;
		else {
			// global $oDb;
			$oDb = $this->get_db ("conf");
			if (!$this->id_secc)
				$this->set_idsecc();
			if (!$this->id_secc)
				$this->errores ("Error Interno");

			if (empty ($this->_seccion['secc_pltpath'])) {
				$pltpath = $this->getFromKrn('plt_path');
				if (empty($pltpath)) {
					$oDb->libera ($id);
					$consulta = "SELECT valor FROM _main WHERE nombre='plt_dir'";
					$id = $oDb->query ($consulta);
					$aTmp = $oDb->fetch_array ($id);
					$oDb->libera ($id);
					$base_path = $aTmp[0];
				} else $base_path = $pltpath;
			} else {
				$base_path = $this->_seccion['secc_pltpath'];
			}

			$path = $base_path;
			$aI = $this->get_iface();

			if (is_numeric($aI['iface']['id']) AND is_array($this->_aIfaces['iface'][$aI['iface']['id']])) {
				if (!empty($this->_aIfaces['iface'][$aI['iface']['id']])) 
					$path .= ((!empty($path)) ? '/' : '').$this->_aIfaces['iface'][$aI['iface']['id']]['path'];
			}
			if (is_numeric($aI['lang']['id']) AND is_array($this->_aIfaces['lang'][$aI['lang']['id']])) {
				if (!empty($this->_aIfaces['lang'][$aI['lang']['id']])) 
					$path .= ((!empty($path)) ? '/' : '').$this->_aIfaces['lang'][$aI['lang']['id']]['path'];
			}

			$this->plt_dir = $path.'/';
		}
		return;
	}

	/**
   *      Coger directorio de plantillas
   *      @return  un string con el nombre relativo  del directorio de slas plantilas
   */
	function get_pltdir () {
		return $this->plt_dir;
	}

	/********** CONFIGURACION GENERAL *****************/

	/*
	 * documentar -motor plantillas, comentado :??- 
	 */

	/**
   * Coger las tablas base
   * @return   $this->tb_base
   */
	function get_tb_base () {
		return $this->tb_base;
	}

	function get_id_subsecc () {
		return $this->id_secc;
	}
	function get_subsecc_name () {
		return $this->seccion;
	}
	function get_subsecc_display () {
		return $this->seccion_visual;
	}
	function get_subsecc_querystring () {
		return $this->secc_querystring;
	}
	// Documentar!!
	function get_section_name () {
		return $this->_seccion['name'];
	}
	function get_section_title () {
		return $this->_seccion['titulo'];
	}
	function get_old_subsecc_name () {
		return $this->old_secc_name;
	}
	function get_old_id_subsecc () {
		return $this->old_secc;
	}
	function get_old_subsecc_querystring () {
		return $this->old_secc_querystring;
	}

			/**
         *Obtiene el nombre de seccion antigua para la comprobacion en init()
         *de si se refresca la configuracion del objeto total o parcialmente.
         */
	function get_oldsecc () {
		return $this->old_secc;
	}

	/**
   *Devuelve al motor de plantillas el id que tiene k usar caso de
   *no tener que hacer la query el motor de plantillas.
   */
	function get_id ($plt = "") {
		$nombre = $this->get_plt_name ($plt);
		if (is_object($this->b_activa)) $id = $this->b_activa->get_id ($this, $nombre);
		return $id;
	}

	function set_idsecc ($seccion = "", $bOverride = FALSE) {
		// global $oDb;
		// debug("wolSession::set_idsecc($seccion,$bOverride) ");
		if (!isset($bOverride)) $bOverride = false;
		$oDb = &$this->get_db ("conf");
		if (empty ($this->tb_secciones)) {
			$this->perror(1,'KERNEL_CONF','Error interno de configuracion, Leaks en las sesiones');
			return 0;
		}

		if (empty ($seccion))
			$seccion = $this->seccion;
		else {
			if ($this->debug & DBUG_MODS)
				debug ("SubSeccion - Act = $ss_act ; Ant = ".$this->get_old_subsecc_name()." Recarga: ".$this->bRecarga);
			//$ss_act = $this->get_subsecc_name ();
			// if (strcasecmp ($this->get_old_subsecc_name(), $ss_act) AND ! $bOverride) 
			if (!$this->bRecarga AND !$bOverride) {
				$ss_secc_name = $this->get_subsecc_name ();
				$ss_secc = $this->get_id_subsecc ();
				$ss_secc_querystring = $this->secc_querystring;
			} 
		}

		// Log-out no cuenta como query_string.
		// if (strcmp($GLOBALS['QUERY_STRING'],'logout=1')) 
		if ( !(int)$GLOBALS['logout'] ) {
			$this->secc_querystring = $GLOBALS['QUERY_STRING'];	// Atributo sin documentar
		} else $this->secc_querystring = NULL;

		if (strcmp($seccion,$this->get_subsecc_name())) {
			$retval = false;
			$consulta = "SELECT * FROM ".$this->tb_secciones;
			$consulta .= " WHERE nombre = '$seccion'";
			$id = $oDb->query ($consulta);
			/*
			 * Este error de db corrupta (caso de haber 2 registros en la tabla de secciones con el mismo nombre) ha de ser tratado de
			 * otra forma (por ejemplo con el modulo de logs? ;) 
			 */
			$num_rows = $oDb->num_rows ($id);
			if ($num_rows > 1) {
				$this->id_secc = 0;
				$this->errores ("Base de Datos Corrupta: Dos secciones con el nombre $seccion");
				return;
			} elseif (!$num_rows) {	  // El nombre ($seccion) no es de una Seccion.
				$oDb->libera ($id);
				$consulta = "SELECT * FROM ".$this->tb_sub_secc;
				$consulta.= " WHERE nombre='$seccion'";
				$id = $oDb->query ($consulta);
				$num_rows = $oDb->num_rows ($id);
				if ($num_rows) {		  /* hemos encontrado la sub-seccion */
					$aTmp = $oDb->fetch_assoc($id);
					$this->id_secc = $aTmp["id_sub_secc"];
					$this->seccion = $seccion;
					$this->seccion_visual = $aTmp["nombre_visual"];
					if ($this->debug & DBUG_MODS) debug ("set_idsecc():this->seccion = $this->seccion");
					$this->tb_base = $aTmp["tb_base"];
	//aviso("asignando include ".$aTmp["script"]);
					$this->include = $aTmp["script"];
					$this->_aSeccion = $aTmp;
				} elseif (is_numeric ($seccion)) {	// Probamos a ver si por id_sub_secc coincide.
					$oDb->libera ($id);
					$consulta = "SELECT * FROM ".$this->tb_sub_secc;
					$consulta.= " WHERE id_sub_secc=".(int) $seccion;
					$id = $oDb->query ($consulta);
					$num_rows = $oDb->num_rows ($id);
					if ($num_rows) {
						$oDb->fetch_assoc($id);
						$this->id_secc = $aTmp["id_sub_secc"];
						$this->seccion = $aTmp["nombre"];
						$this->seccion_visual = $aTmp["nombre_visual"];
						if ($this->debug & DBUG_MODS)
							debug ("set_idsecc(nombre subsecc):this->seccion = $this->seccion");
						$this->tb_base = $aTmp["tb_base"];
						$this->include = $aTmp["script"];
						$this->_aSeccion = $aTmp;
					} else {
						$this->id_secc = 0;
						$this->errores ("No existe esa seccion");
					}
				}
				$oDb->libera ($id);

				  /** Documentar la variable _seccion_name **/
				if ((int) $this->id_secc) {	// Si hemos encontrado la subseccion, buscamos su Seccion.
					$cons = "SELECT t2.nombre, t2.titulo, t2.id_seccion, t2.plt_dir ".
						"FROM ".$this->tb_secciones." t2, ".$this->tb_sec_subsecc." t1 ".
						"WHERE t2.id_seccion = t1.id_seccion AND t1.id_sub_secc = ".$this->id_secc;
					$rs = $oDb->query ($cons);
					if ($oDb->num_rows ($rs)) {
						$aTmp = $oDb->fetch_assoc ($rs);
						if (!is_numeric ($this->_seccion['id']) OR $this->_seccion['id'] != $aTmp['id_seccion']) {
							$this->unset_vars ('SECCION');
						}
						$this->_seccion['name'] = $aTmp['nombre'];
						$this->_seccion['titulo'] = $aTmp['titulo'];
						$this->_seccion['id'] = $aTmp['id_seccion'];
						$this->_seccion['secc_pltpath'] = $aTmp['plt_dir'];	// Documentar!
					} else {
						if (is_numeric ($this->_seccion['id'])) {
							$this->unset_vars ('SECCION');
						}
						$this->_seccion['name'] = NULL;
						$this->_seccion['titulo'] = NULL;
						$this->_seccion['secc_pltpath'] = NULL; // Documentar!
					}
				} else {
					if (is_numeric ($this->_seccion['id'])) {
						$this->unset_vars ('SECCION');
					}
					$this->_seccion['name'] = NULL;
					$this->_seccion['titulo'] = NULL;
					$this->_seccion['secc_pltpath'] = NULL; // Documentar!
				}
				$retval = TRUE;
			}
			if (!$retval) {			  // Si no estaba en 'Secciones' y por tanto hayamos buscado su sub-seccion (indep del exito)
				$aSeccion = $oDb->fetch_array ($id);
				if (!is_numeric ($this->_seccion['id']) or $this->_seccion['id'] != $aSeccion['id_seccion']) {
					$this->unset_vars ('SECCION');
				}
				$this->_seccion['name'] = $aSeccion['nombre'];	// Documentar!
				$this->_seccion['titulo'] = $aSeccion['titulo'];	// Documentar!
				$this->_seccion['id'] = $aSeccion['id_seccion'];	// Documentar!
				$this->_seccion['secc_pltpath'] = $aSeccion['plt_dir'];	// Documentar!
				$this->id_secc = $aSeccion["main_sub"];
				if (!empty ($aSeccion["script"]) or strcmp ($aSeccion["script"], "NULL"))
					$this->include = $aSeccion["script"];
				$this->tb_base = $aSeccion["tb_base"];
				$oDb->libera ($id);
				$consulta = "SELECT * FROM ".$this->tb_sub_secc;
				$consulta.= " WHERE id_sub_secc = ".$this->get_id_subsecc ();
				$oDb->query ($consulta);
				if ($oDb->num_rows ()) {
					$aSeccion = $oDb->fetch_assoc();
					// No poner el nombre de Seccion donde va el nombre de la subseccion.
					$this->seccion = $aSeccion['nombre'];
					$this->_aSeccion = $aSeccion;
					//debug("Secicon : ".$this->seccion);
					// $this->seccion = $seccion;

					$this->seccion_visual = $aSeccion['nombre_visual'];
					if (!empty ($aSeccion['script']) OR strcmp ($aSeccion['script'], "NULL")) $this->include = $aSeccion['script'];
					if ($this->debug & DBUG_MODS) debug ("set_idsecc(por seccion):this->seccion = $this->seccion");
				} else $this->seccion = $seccion;
			}
		} else $retval = true;

		if (!$bOverride) {
			if (empty ($ss_secc_name))
				$ss_secc_name = $this->get_old_subsecc_name ();
			if ($this->debug & DBUG_MODS)
				debug ("SubSeccion - Act = $seccion ; Ant = $ss_secc_name ");
			if (strcasecmp ($seccion, $ss_secc_name) ) {
				// debug("Cambiando antigua SS ".$this->old_secc_name." por ".$ss_secc_name." dado que seccion: ".$seccion);
				$this->old_secc_name = $ss_secc_name;
				$this->old_secc = $ss_secc;
				$this->old_secc_querystring = $ss_secc_querystring;
				$this->_aCurEntityList = array();
			}
		}
		if ((bool)$bOverride) {
			// debug("Cambiando SS ".$this->old_secc_name." por actual: ".$this->get_subsecc_name());
			$this->old_secc_name = $this->get_subsecc_name();
			$this->old_secc = $this->get_id_subsecc();
			$this->old_secc_querystring = $this->secc_querystring;
		}
		return $retval;
	}

			/******** Manejo objeto(s) wolDB ****************/

	/**
   *Introducir un valor en la tabla _main
   * @param     $nombre de la variable a modificar
   * @param     $valor a meter
   * @param     $oDb Objeto wol_db a usar [opt]
   */
	function set_main_value ($nombre = "", $valor = "", $oDb = "") {
		// global $oDb;
		if ($nombre == "") {
			return 0;
		} else {
			// $oDb = $this->get_db("conf");
			$consulta = "INSERT INTO _main VALUES (NULL, '$nombre', '$valor')";
			if (!is_object ($oDb)) {
				$id = $this->query ($consulta);
				$this->libera ($id);
			} else {
				$id = $oDb->query ($consulta);
				$oDb->libera ($id);
			}
		}
		return 1;
	}

	/**
   * Leer valor de configuracion
   * Si el valor de nombre esta en la propiedad $configuracion[$nombre]
   *lo retorn .Sino lo lee de la tabla _main y lo inserta en el array
   *
   * @param $nombre para leer
   * @param    $oDb Objeto wol_db a usar [opt]
   * @return el valor de nombre
   *
	 * Tenemos 2 Versiones de este metodo. Una para el kernel de los proyectos y otra para la herramienta Pulsar.
	 */
	function read_main_value ($nombre = "") {
//debug("leyendo $nombre");
		if ($nombre == "")
			return "";
		else {
			$main_values = $this->get_var ("main_values");
//     depurar_array($main_values);     
			if (isset ($main_values[$nombre])) {
//      debug("de sesion $main_values[$nombre]");
				return $main_values[$nombre];
			} else {
				$consulta = "SELECT nombre , valor  FROM _main";
				$oDb = $this->get_db ("conf");
				$id = $oDb->query ($consulta);
				$tabla = array ();
				while ($par = $oDb->fetch_array ($id)) {
//              depurar_array($par);
					$tabla[$par['nombre']] = $par['valor'];
				}
//          depurar_array($tabla);      
				$this->set_var ("main_values", $tabla);
				$oDb->libera ($id);
//        debug("de primera$tabla[$nombre]");
				return $tabla[$nombre];
			}
		}
	}
	/*
	 * Version para Pulsar *(off) function read_main_value($nombre = "",$oDb = "") { //global $oDb; if($nombre == "") return "";
	 * else{ $consulta = "SELECT valor FROM _main WHERE nombre='$nombre'"; if (!is_object($oDb)) { $id = $this->query($consulta);
	 * $aTmp = $this->fetch_row($id); $this->libera($id); } else { $id = $oDb->query($consulta); $aTmp = $oDb->fetch_row($id);
	 * $oDb->libera($id); } return $aTmp[0]; } } 
	 */


					 /***** Sacar a wolIndex ****/

				/****** conectar_dbs($typo)
				*                Este metodo conecta los distintos tipos de instancias wolDB almacenadas.
				*                Actualmente solo hay de datos (data) y de configuracion (conf), se crean los
				*                objetos si es necesario, y son conectados y almacenados de nuevo.
				*                El tipo por defecto es conf.
				*                Actualmente solo hay una conexion por tipo. (set_db(tipo))
				*                Asimismo este objeto reconecta todas las instancias contenidas en la sesion
				*                        caso de que se le haga una solicitud que no coincida en tipo con 'data'
				*                        o 'conf' y que el set_db se haya hecho persistente.
				********/
	function conectar_dbs ($type = NULL) {
		if ($this->debug & DBUG_DB)
			debug ("conectar_dbs($type)");

		if (!$type || ($type AND ! strcmp ($type, "conf"))) {
			$oDb = &$this->get_db ("conf");
			if (is_a($oDb,'wol_db')) {
				if ($this->debug & DBUG_DB) debug ("oDb(conf) es un objeto");
			} else {
				if (is_a($GLOBALS['INMERSA_BASEDB'],'wol_db')) 
					$oDb = &$GLOBALS['INMERSA_BASEDB'];
			}

			if (!is_object ($oDb)) {
				if ($this->debug & DBUG_DB)
					debug ("creamos wolDB para la configuracion");
				$oDb = new wol_db ($this->App_Name);
				$oDb->init ();
			} else {
				$oDb->init ();
			}

			if (!$oDb->conectado(1)) {
				$oDb->conecta (1);
			}
			$this->set_db ("conf", &$oDb, true);
			$this->activate_db ('conf');
			if ($this->debug & DBUG_DB)
				debug ("El sql point ta en ".$oDb->SQL_point);

			// $oDb=$this->db;
		}
		elseif (!strcmp ($type, "data")) {
			$oDb = &$this->get_db('data');
			if (!is_object ($oDb)) {	// Si no existe lo creamos
				$l = $this->read_main_value ("db_data_login");
				$p = $this->read_main_value ("db_data_passwd");
				$s = $this->read_main_value ("db_data_server");
				$db = $this->read_main_value ("db_data_dbase");
				$pt = $this->read_main_value ("db_data_port");
				if ($this->debug & DBUG_DB)
					debug ("Creando this->db apuntando a $db");
				// $this->db = new wol_db ($this->App_Name, $l, $p, $s, $db, $pt);
				// $this->db->init ();
				$oDb = new wol_db ($this->App_Name, $l, $p, $s, $db, $pt);
				$oDb->init ();
			} else
				$oDb->init ();

			// $this->db->conecta (1);
			if (!$oDb->conectado(1)) $oDb->conecta (1);
			$this->set_db ("data", &$oDb, true);
			$this->activate_db ("data");
		}
		else {							 /** si no es data ni conf... conectamos el resto de instancias **/
			if ($this->debug & DBUG_DB)
				debug ("conectar_dbs ni data ni conf");
			for (; list ($dbconname, $oWolDB) = each ($this->dbs);) {
				if ($this->debug & DBUG_DB)
					debug ("revisando $dbconname");
				// comprobacion
				if (!is_object ($oWolDB) ||	// errores -ignore-
					 !strcmp ($dbconname, "data") ||	// si data o conf
					 !strcmp ($dbconname, "conf"))
					continue;		  // ignorar

				if ($this->dbs_pconn[$dbconname] AND	// Si pconn
					 ! $this->dbs[$dbconname]->conectado ()) {	// y no conectado
					if ($this->debug & DBUG_DB)
						debug ("conectado = ".$this->dbs[$dbconname]->conectado ()."; reconectando $dbconname...");
					$this->dbs[$dbconname]->conecta (1);	// conectar obj
				}
			}							  // fin del for this->dbs
		}								  // fin del if (data o conf)
		if ($this->debug & DBUG_DB)
			debug ("fin de conectar dbs");
	}

					  /**
                 *Cierra la base de datos
                 */
	function cerrar_dbs () {
		// $this->dbs[data] = NULL;
		// unset($this->dbs[data]);
		for (; list ($r, $o) = each ($this->dbs);) {
			if ($this->debug & DBUG_DB)
				debug ("cerrar_dbs($r) clase: ".get_class($o));
			if (!is_object ($o)) {
				//Comprobar que no pase nada.. 
				// $this->dbs[$r] = NULL;
				unset ($this->dbs[$r]);
			} else {
				$this->dbs[$r]->cerrar ();
			}
		}
		reset ($this->dbs);
	}

					 /**
                *Pone el nombre de la base de datos a NULL */
	function restore_dbpoint () {

//debug("wolsesion->restore($db_name)");
		$this->db_name = NULL;
	}

					 /**
                * Establece valor de this->db */
	function set_db_conn (&$oDb) {
		$this->db = &$oDb;
		return;
	}

										  /**
                                * Obtienes conexion activa y sino this->db. 
																*/
	function get_db_conn () {
		if (!empty ($this->db_name))
			return $this->dbs[$this->db_name];
		else
			return $this->db;
	}

	/**
	 * Obtienes conexion activa y sino this->db. 
	 */
	function set_db ($name, &$oDb, $persistente = 0) {
		if ($this->debug & DBUG_DB)
			debug ("sesiones.inc:set_db($name,$persistente)");
		$this->dbs[$name] = &$oDb;
		$this->dbs_pconn[$name] = (int) $persistente;
	}

	function &get_db ($name = NULL,$bStore = false, $bPersistent = true) {
		if ($this->debug & DBUG_DB)
			debug ("sesiones.inc:get_db($name)");
		if (empty ($name) OR ! isset ($name))
			$name = $this->db_name;
		if (is_object ($this->dbs[$name])) {
			return $this->dbs[$name];
		} else {
			if (!isset($bStore)) $bStore = false;
			if (!isset($bPersistent)) $bPersistent = true;
			$oDb = &$this->get_db ('conf');
			$db = $oDb->read_main_value ('db_'.$name.'_dbase');
			$login = $oDb->read_main_value ('db_'.$name.'_login');
			$passwd = $oDb->read_main_value ('db_'.$name.'_passwd');
			$server = $oDb->read_main_value ('db_'.$name.'_server');
			$port = $oDb->read_main_value ('db_'.$name.'_port');
			if (!empty ($db) AND ! empty ($login) AND ! empty ($server)) {

				/** **/
				$this->dbs[$name] = new wol_db ($this->App_Name, $login, $passwd, $server, $db, $port);
				if (is_object ($this->dbs[$name])) {
					$this->dbs[$name]->init ();
					if (!is_numeric($this->dbs_pconn[$name])) $this->dbs_pconn[$name] = 1;
					if (!$this->dbs[$name]->conectado(1)) $this->dbs[$name]->conecta(1);
					return $this->dbs[$name];
				} else
					$this->dbs[$name] = NULL;

				/** **
				$tmpdb = new wol_db($this->App_Name,$login,$passwd,$server,$db);
				if (is_object($tmpdb)) {
					$tmpdb->init();
					debug("Ahora le damos el INIT");
					$this->set_db($name,$tmpdb,1);
					return $tmpdb;
				} else $this->dbs[$name] = NULL;
				/** **/
			}
		}
		return NULL;
	}

	function get_dbconname () {
		return $this->db_name;
	}

	function reset_db ($name) {
		unset ($this->dbs[$name]);
	}

				/**
				* Establece la instancia wolDB activa
				*/
	function activate_db ($db_name) {
		if ($this->debug & DBUG_DB)
			debug ("wolsesion->activate_db($db_name)");
		if (is_object ($this->dbs[$db_name]))
			$this->db_name = $db_name;
	}

								/***** FIN de Sacar a wolIndex ****/


	/** Metodos a Borrar **/
	function obtener_clave ($a = "") {
		debug("Llamada a metodo obtener clave de wolSession");
		if (!empty ($this->db_name))
			return $this->dbs[$this->db_name]->obtener_clave ($a);
		else
			return $this->db->obtener_clave ($a);
		return $db->obtener_clave ($a);
	}


	/*
	 * Tite: mirar a ver que es esto. * function esta_en($a="",$b="",$c=""){ if (!empty($this->db_name)) $db =
	 * &$this->dbs[$this->db_name]; return $db->esta_en($a,$b,$c); } 
	 */


					 /********** API con el MOTOR de PLANTILLAS ************/

					 /***** Info y PUNTEROS de PLANTILLAS ******/

	/**
	  * Metodo encargado de parsear la cadena indicativa de los parametros a los metodos de formateo o parseo
	  * a fin de obtener una lista de valores facilmente manejable por la instancia para saber si ha de obtener
	  * variables de la sesion y bajo que nombre.
	  **/
	function _parseMethodParams($str) {
		if (empty($str)) return NULL;
		// debug("Parseando: $str ");
		// Regexp que rompe por "*"
		$aTmp = preg_split("/([\"][\w\. ]+[\"])+/",$str,-1,PREG_SPLIT_DELIM_CAPTURE | PCRE_EXTEND);

		// Componemos una pila con las cadenas separadas por ' ', salvo los incluidos entre "
		$stPList = array();
		for ($i=0;$i<sizeof($aTmp);$i++) {
			$val = trim($aTmp[$i]);
			if (empty($val)) continue;
			if ($val[0] != '"') {
				$aSps = split(' ',$val);
				foreach ($aSps as $spval) 
					if (!empty($spval)) {
						$spval = trim($spval);
						$spval = trim($spval,'\"');
						array_push($stPList,$spval);
					}
			} else {
				$val = trim($val);
				$val = trim($val,'\"');
				array_push($stPList,$val);
			}
		}

		// debug("La pila contiene: ");
		// print_r($stPList);
		$aRetVal = array();
		$iNoneVarVal = 0;
		$bChangeItem = false;
		$aData = array();
		// Para cada elemento de la lista ..
		while ($val = array_shift($stPList)) {
			// debug("<hr>Elemento $val .. ");

			// Comprobamos que tenga : para indicarnos si estamos en un valor o variable y que no hayamos terminado
			// de procesar un grupo, en cuyo caso, hay que almacenarlo en el else
			if (!strchr($val,':') AND !$bChangeItem) {
				// debug("El valor $val no contiene : cuando estamos en un $iNoneVarVal ");

				// Si sabemos ya si estamos en un var o un val, procedemos con ello.
				if ($iNoneVarVal) {
					if ($iNoneVarVal == 1) {
						// Si es una variable, no esperamos mas, no hay mas posibilidades.

						// debug("Sesion - varname = $val ");
						$aData['varname'] = $val;
						$bChangeItem = true;
					} else {
						// Si es un valor ..
						if (strchr($val,'=')) {
							// puede venir en formato <nombredevalor>=
							$aTmp = split('=',$val);
							$aData['valuename'] = $aTmp[0];
							if (strlen($aTmp[1])>=1) $aData['valuedata'] = $aTmp[1];
						} else {
							// o puede venir en formato "<nombredevalor>"=  lo que implica 2 elementos distintos en la pila.
							$next = array_shift($stPList);
							// debug("valuedata = $val comprobando siguiente elemento: $next ");
							if ($next != '=') {
								// Si el siguiente no es un = (<nombreval>="<este elemento>"), asumimos que este es el valor en si

								// debug("Que jodio. ($next) .. $val ");
								$aData['valuedata'] = $val;
								// Reapilamos el siguiente elemento, por si vale.
								array_unshift($stPList,$next);
								$bChangeItem = true;
							} else {
								// Si el siguiente elemento es un = , esta claro que este sera el nombre del valor.

								// debug("ha sido valuename = $val");
								$bChangeItem = false;
								$aData['valuename'] = $val;
							}
						}
					}
				} else {
					// Si todavia no sabemos si estamos en var o val, es porque no se ha usado el formato <tipo>: , asi que
					// buscamos un <xxxx>=<yyy> que significara, que es un valor, sino sera una variable. de cualquier forma,
					// reapilamos el resultado, una vez indicado el tipo, para que se procese bien.

					// debug("<b>Analizando</b> $val para saber si va a ser una variable o un valor ... ");
					if (strchr($val,'=')) {
						// debug("Otro decreto, valor, por el = que tiene");
						$iNoneVarVal = 2;
						array_unshift($stPList,$val);
					} else {
						$next = array_shift($stPList);
						if ($next == '=') {
							// debug("Decreto que un valor por $next ");
							$iNoneVarVal = 2;
						} else {
							// debug("<b>VARIABLE</b>.. a ver que hacemos con $val ");
							$iNoneVarVal = 1;
						}
						array_unshift($stPList,$next);
						array_unshift($stPList,$val);
					}
				}
			} else {
				// Estamos terminando o empezando algo, el siguiente elemento, _si_ hay que analizarlo

				$bChangeItem = false;
				// SI ya hay algo que almacenar, lo almacenamos.
				if ($iNoneVarVal and is_array($aData) and sizeof($aData)) {
					// debug("<b>Almacenando</b> como valor de retorno : ");
					// print_r($aData);
					array_push($aRetVal,$aData);
					$aData = array();
					$iNoneVarVal = 0;
				}
				// Una vez almacenado, si este valor que acabamos de extraer de la pila, nos indica si estamos
				// en una variable o valor, asi lo indicamos.
				if (strchr($val,':')) {
					$aTmp = split(':',$val);
					// debug("$val <b>si</b> que contiene <b>:</b> ");
					// print_r($aTmp);
					switch ($aTmp[0]) {
						case 'var':
							$iNoneVarVal = 1;
							break;
						case 'val':
							$iNoneVarVal = 2;
							break;
					}
					// SI, junto con el <tipo>: , viene mas info, hay que apilarla, aqui solo indicamos si va a ser var o val
					if (!empty($aTmp[1])) {
						// debug("RE-apilando como $iNoneVarVal -> ".$aTmp[1]);
						array_unshift($stPList,$aTmp[1]);
					}
				} else {
					// Si el elemento siguiente no contiene : , es que solo se quiso que almacenasemos un resultado, lo reapilamos
					// para que la otra parte del if, analice si sera var o val (aqui solo el metodo directo)
					// debug("No se _si_ reapilar $val ");
					array_unshift($stPList,$val);
				}
			}
			// debug("Resumen por pasada: ");
			// print_r($aData);
		}
		if ($iNoneVarVal and is_array($aData) and sizeof($aData)) {
			// Al ultimo elemento, no le da tiempo a pasar por el else bChangeItem, dado que no hay mas, lo almacenamos aqui.
			// debug("AL FINAL - <b>Almacenando</b> como valor de retorno : ");
			// print_r($aData);
			array_push($aRetVal,$aData);
			$aData = array();
			$iNoneVarVal = 0;
		}

		// debug("Valor de <b>Retorno</b>: ");
		// print_r($aRetVal);
		return $aRetVal;
	}

	function _fetchMethodParams($aPlist) {
		if (!is_array($aPlist) or !sizeof($aPlist)) return NULL;
		$aRetVal = array();
		$i = 0;
		foreach ($aPlist as $aP) {
			if (!empty($aP['varname'])) $aRetVal[$aP['varname']] = $this->get_var($aP['varname']);
			elseif (!empty($aP['valuedata']))
				if (!empty($aP['valuename'])) $aRetVal[$aP['valuename']] = $aP['valuedata'];
				else $aRetVal[$i] = $aP['valuedata'];
			$i++;
		}
		return $aRetVal;
	}

	function &_getCallBackMethod($func) {
		static $aMethodList = array('AllowedLink', 'AllowedPII','AllowedAction');

		if (empty($func)) return NULL;
		$aF = NULL;
		if (strchr($func,'::')) {
			$aCF = split('::',$func);
			if (sizeof($aCF)==2) {
				$aF[0] = $aCF[0];
				$aF[1] = $aCF[1];
				$source = $aCF[0];
				$type = 'ClassMethod';
			}
		} elseif (strchr($func,'->')) {
			$aOF = split('->',$func);
			$oI = &$this->getVarByRef($aOF[0]);
			$source = $aOF[0];
			if (is_object($oI)) {
				$type = 'InstanceMethod';
			} else {
				if (is_object($this->_aModList[$aOF[0]])) {
					$oI = &$this->_aModList[$aOF[0]];
					$type = 'ModuleMethod';
				} else 
					foreach ($this->_aActiveModules as $modname) {
						if ($this->_aModulos[$modname]['class'] == $aOF[0]) {
							if (is_object($this->_aModList[$modname])) $oI = &$this->_aModList[$modname];
							$type = 'ModuleMethod';
						}
					}
			}
			if (is_object($oI)) {
				$aF[0] = &$oI;
				$aF[1] = $aOF[1];
			}
		} elseif (in_array($func,$aMethodList) and method_exists($this,$func)) {
			$aF = array(&$this,$func);
			$source = '__App__';
			$type = 'InstanceMethod';
		} elseif (function_exists($func)) {
			$aF = $func;
			$source = 'Spare';
			$type = 'Function';
		} 
		if ($aF) $retval = array('call' => &$aF, 'type' => $type, 'source' => $source);
		return $retval;
	}

	function _arrayMapRecursive(&$func,$value = NULL,$aP = NULL,$index = 1,$stPath = NULL) {
		if (!is_numeric($index) or $index<1) $index = 1;
		// debug("Llamada a <b>arrayMapRecursive</b> ... ");
		if (is_array($value)) {
			$aRetVal = array();
			foreach (array_keys($value) as $key) {
				$valor = &$value[$key];
				if (!is_array($stPathN)) {
					// debug("Asignando al N la base: ");
					// print_r($stPath);
					$stPathN = $stPath;
				} else array_pop($stPathN);
				if (is_array($stPathN)) array_push($stPathN,$key);
				// Una copia de los argumentos, importante
				$args = $aP;
				if (is_array($valor)) {
					$aRetVal[$key] = $this->_arrayMapRecursive($func,$valor,$aP,$index,$stPathN);
				} else {
					array_splice($args,$index-1,0,array($valor));
					if (is_array($stPathN) and sizeof($stPathN)) array_splice($args,sizeof($args),0,array($stPathN));
					// debug("Llamando a: $func con ");
					// print_r($stPathN);
					$aRetVal[$key] = call_user_func_array($func,$args);
				}
			}
		} else {
			// debug("<b>No es array</b>, asi que aqui llamariamos al invento: $func");
			// Una copia de los argumentos, importante
			$args = $aP;
			array_splice($args,$index-1,0,array($value));
			if (is_array($stPath) and sizeof($stPath)) array_splice($args,sizeof($args),0,array($stPath));
			// debug("Sin saber, la ruta: para ($value) ");
			// foreach ($args as $val) 
				// if (is_object($val)) debug("Instancia ".get_class($val));
				// elseif (is_array($val)) debug("Un vector con ".sizeof($val)." items ");
				// else debug("Parametro: ".$val);
			// print_r($stPath);
			$aRetVal = call_user_func_array($func,$args);
		}
		return $aRetVal;
	}

	/**
	  * Metodo encargado del almacenmiento del tipo de datos por entidad. Asi como 
	  *	los valores, de las funciones de formato y parseo, que sobreescriben los valores por defecto.
	  */
	function setEntityDataType($entidad,$aStruct = NULL) {
		if (empty($entidad)) return false;
		// Si en esta app no se formatean datos automaticamente: no hacemos nada.
		if (!$this->_getKrnCfg('format_data')) return false;

		// if (!is_array($aStruct)) return NULL;
		// debug("wolSesion::setEntityDataType($entidad)");

		$retval = false;
		if (!in_array($entidad,$this->_aCurEntityList)) array_push($this->_aCurEntityList,$entidad);

		if (!is_array($this->aEntityData[$entidad])) {
			if (is_array($aStruct))
				foreach ($aStruct as $aSt) {
					$this->aEntityData[$entidad][$aSt['name']]['struct'] = $aSt;
				}

			$db = $this->get_db('conf');
			if (!strcasecmp($entidad,'__spare__')) {
				$cons = 'SELECT '.
							'id_entity_field as "id", '.
							'nombre as "campo", '.
							'format_method as "format", '.
							'format_params as "format_params", '.
							'parser_method as "parser", '.
							'parser_params as "parser_params", '.
							'data_css as "data_css", '.
							'label_css as "label_css" '.
							'FROM Entity_format_style '.
							'WHERE nombre not like "%.%" ';
				$this->aEntityData['__spare__'] = array();
			} else {
				$cons = 'SELECT '.
							'id_entity_field as "id", '.
							'SUBSTRING(nombre,LENGTH("'.$entidad.'.")+1) as "campo", '.
							'format_method as "format", '.
							'format_params as "format_params", '.
							'parser_method as "parser", '.
							'parser_params as "parser_params", '.
							'data_css as "data_css", '.
							'label_css as "label_css" '.
							'FROM Entity_format_style '.
							'WHERE nombre like "'.$entidad.'.%" ';
			}
			$idrs = $db->query($cons);
			if ($db->num_rows($idrs)) {
				while ($aTmp = $db->fetch_assoc($idrs)) {
					if (!empty($aTmp['format'])) $this->aEntityData[$entidad][$aTmp['campo']]['format'] = $aTmp['format'];
					if (!empty($aTmp['format_params'])) 
						$this->aEntityData[$entidad][$aTmp['campo']]['format_params'] = $this->_parseMethodParams($aTmp['format_params']);
					if (!empty($aTmp['parser'])) $this->aEntityData[$entidad][$aTmp['campo']]['parser'] = $aTmp['parser'];
					if (!empty($aTmp['parser_params'])) 
						$this->aEntityData[$entidad][$aTmp['campo']]['parser_params'] = $this->_parseMethodParams($aTmp['parser_params']);
					if (!empty($aTmp['data_css'])) $this->aEntityData[$entidad][$aTmp['campo']]['data_css'] = $aTmp['data_css'];
					if (!empty($aTmp['label_css'])) $this->aEntityData[$entidad][$aTmp['campo']]['label_css'] = $aTmp['label_css'];
				}
				$retval = true;
			}
			$db->libera($idrs);
		}

		return $retval;
	}


	function setEntityDataLink($linkname,$entity,$field = NULL) {
		if (!$this->_getKrnCfg('format_data')) return true;
		if (empty($entity) AND empty($field)) return false;

		if (!is_array($this->aEntityData[$entity]) AND empty($field) ) {
			$field = $entity;
			foreach ($this->aEntityData as $ent => $aEnt) {
				if (is_array($aEnt[$field])) {
					$entity = $ent;
					break;
				}
			}
		}

		if (empty($entity) OR empty($field) OR !is_array($this->aEntityData[$entity][$field])) return false;
		$this->aEntityData['__aliases__'][$linkname] = $entity.'.'.$field;
	}
	/**
	  * Metodo que retorna bool, dependiendo de si disponemos de informacion de formato/parseo sobre la entidad.
	  */
	function gotEntityDataType($entidad) {
		if (!$this->_getKrnCfg('format_data')) return true;
		if (empty($entidad)) return true;

		if (!empty($this->aEntityData['__aliases__'][$entidad])) $entidad = $this->aEntityData['__aliases__'][$entidad];

		if (!in_array($entidad,$this->_aCurEntityList) AND is_array($this->aEntityData[$entidad])) array_push($this->_aCurEntityList,$entidad);

		if (is_array($this->aEntityData[$entidad])) return true;
		else return $this->setEntityDataType($entidad);
	}

	function getEntityDataType($entidad,$bForceFieldSeek = FALSE) {
		if (!$this->_getKrnCfg('format_data')) return NULL;

		$retval = NULL;
		if (!empty($this->aEntityData['__aliases__'][$entidad])) $entidad = $this->aEntityData['__aliases__'][$entidad];

		if (strchr($entidad,'.')) {
			$aTmp = split('\.',$entidad);
			$retval = $this->aEntityData[$aTmp[0]][$aTmp[1]];
			if (is_array($retval)) $retval['entityname'] = $aTmp[0];
			// debug("wolSesion::getEntityDataType($entidad) : ");
			// print_r($retval);
		} else {
			if (!is_array($this->aEntityData['__spare__'])) $this->setEntityDataType('__spare__');
			if (isset($this->aEntityData[$entidad])) {
				$retval = $this->aEntityData[$entidad];
			} else if (is_array($this->aEntityData['__spare__'][$entidad])) {
				$retval = $this->aEntityData['__spare__'][$entidad];
				/** De momento, si no se encuentra en el nombre de entidad, ni en spare, _no_ casamos por nombre de campo **
				  ** Fixme: Supeditar esta accion a una variable de configuracion del kenel. format_strict_asign (o parecido) **/
			} elseif ($bForceFieldSeek)
				foreach ($this->_aEntityList as $ent ) {
					// Si el parametro no es una entidad, miramos si es un campo de alguna entidad reciente.
					if (is_array($this->aEntityData[$ent][$entidad])) {
						$retval = $this->aEntityData[$ent][$entidad];
						$retval['entityname'] = $ent;
						break;
					}
					/** **/
				}
		}
		return $retval;
	}

	/**
	  *  Metodo para formatear por tipo de dato.
	  */
	function getDataFormated($campo,$valor,$oSource = NULL) {
		// debug("Formatos .. $campo ");
		// print_r($this->_aDataFormats);
		// debug("getDataFormated($campo)");
		$retval = $valor;
		$aEnt = $this->getEntityDataType($campo);
		if (!is_array($aEnt)) return $valor;

		if (!empty($aEnt['format'])) {
			$aType = &$aEnt;
		} elseif (is_array($this->_aDataFormats[$aEnt['struct']['type']])) {
			$aFmt = $this->_aDataFormats[$aEnt['struct']['type']][$aEnt['struct']['len']];
			if (is_array($aFmt)) $aType = $aFmt;
			else $aType = $this->_aDataFormats[$aEnt['struct']['type']][0];
		}

		if (!empty($aType['format'])) {
			if (!empty($aType['format_params']) and is_array($aType['format_params']) and sizeof($aType['format_params']))
				$aParams = $this->_fetchMethodParams($aType['format_params']);

			if (strstr($campo,$aEnt['entityname'])) {
				$cleanfld = str_replace($aEnt['entityname'].'.','',$campo);
			} else $cleanfld = $campo;

			// debug("Llamadita de rigor .. $cleanfld ");
			// print_r($aType);
			$aF = &$this->_getCallBackMethod($aType['format']);
			// if ($aF) $retval = call_user_func($aF,$valor,&$this,$aParams);
			if ($aF) $retval = $this->_arrayMapRecursive(&$aF['call'],$valor,array(&$this,&$aParams,&$oSource),NULL,
										array('entity'=>$aEnt['entityname'],'field'=>$cleanfld));

			// $stV[$campo] = $this->_arrayMapRecursive(&$aF,$stV[$campo],array(&$this,&$aParams,$datasource),NULL,$aRutaN);
		}
		return $retval;
	}

	/**
	  * Metodo de parseo de datos por tipo.
	  */
	function getDataParsed($varname,$valor,$forcedentity = NULL,$datasource = NULL) {
		// Si no hay extrancion de datos, recientemente, y por tanto nada contra que contrastar, no parseamos
		// debug("getDataParsed ($varname) :: $forcedentity - antes de comprobar la EntityList");
		// print_r($this->_aEntityList);
		if (!is_array($this->_aEntityList) OR !sizeof($this->_aEntityList)) return $valor;

		// debug("getDataParsed ($varname) :: $forcedentity");
		// print_r($this->_aEntityList);
		$valorcopy = $valor;
		$retval = &$valor;
		if (is_array($valor)) {
			// debug("<hr>Obteniendo dato $varname ... ");
			// print_r($this->_aEntityList);
			if (sizeof($valor)) {
				// Inicializamos vector de pilas 
				$foundEntity = NULL;
				$stEntity['__none__'] = array();
				// array_push($stEntity['__none__'],&$valor);
				if (!empty($forcedentity) AND $this->gotEntityDataType($forcedentity) ) {
					$stEntity[$forcedentity] = array();
					// array_push($stEntity[$ent],&$valor);
					$stEntity[$forcedentity][] = &$valor;
					$foundEntity = $forcedentity;
					$cntEntity[$forcedentity] = 0;
				} else {
					// debug("o $forcedentity esta vacio, o no existe el tipo ");
					$stEntity['__none__'][] = &$valor;
					foreach ($this->_aEntityList as $ent) {
						// Si resulta que el nombre de variable coincide con el de la entidad, no se busca en otras.
						if (!strcasecmp($ent,$varname)) {
							// debug("Vector para la _ENTIDAD_ :: $ent - $campo ");

							$stEntity[$ent] = array();
							// array_push($stEntity[$ent],&$valor);
							$stEntity[$ent][] = &$valor;
							$foundEntity = $ent;
							$cntEntity[$ent] = 0;
							break;
						}
						$stEntity[$ent] = array();
						$cntEntity[$ent] = 0;
					}
				}

				// asignamos a las pilas especificas por entidad, de la pila general, los items que le correspondan en base a indice
				if (is_array($stEntity['__none__'])) {
					// Reseteamos los contadores
					foreach ($cntEntity as $id => $none) $cntEntity[$id] = 0;

					while (list($stidx,$stVal) = each($stEntity['__none__']) ) { 
						// Si se ha de insertar el resultado en la pila o no
						$bInsert = true;
						// debug(" ------- desde la pila ------- ");
						if (is_array($stVal)) {
							// Recorremos el vector para determinar a _cual_ (una) de las entidades pueda pertenecer.
							foreach ($stVal as $idx => $val) {

								// debug("idx:: $idx");

								// Buscamos la entidad a la que pueda pertenecer este campo. Solo consideramos que el vector designado
								// por stVal pertenece a la entidad foundEntity cuando mas del 50% de sus campos coinciden con los de la entidad
								if (!is_numeric($idx) AND !$foundEntity) {

									$aT = $this->getEntityDataType($idx,TRUE);
									if (is_array($aT) AND is_numeric($cntEntity[$aT['entityname']])) {
										$cntEntity[$aT['entityname']]++;
										// Comprobamos si hemos llegado a ese 50%
										if ( $cntEntity[$aT['entityname']] / sizeof($stVal) > 0.5 ) {
											$foundEntity = $aT['entityname'];
										}
									}
								}

								// Si el valor del elemento de la pila, es otro vector, se analiza de nuevo en la siguiente... APILALO!
								if (is_array($val)) {
									array_push($stEntity['__none__'],&$stEntity['__none__'][$stidx][$idx]);
								}
							}

							// Si no se ha podido determinar la entidad del vector $stVal, cogemos el de mayor numero de coincidencias.
							if (!$foundEntity) {
								if (is_array($cntEntity))
									foreach ($cntEntity as $ent => $cnt) 
										if (!$foundEntity) $foundEntity = $ent;
										elseif ($cnt > $cntEntity[$foundEntity]) $foundEntity=$ent;
							}

							if ($foundEntity AND $bInsert) {
								// array_push($stEntity[$foundEntity],&$stVal);
								// debug("Found! $foundEntity inserting ... $stidx ");
								// print_r($stEntity['__none__'][$stidx]);

								// No hace falta de-referencia, el contenido ya es un puntero.
								// $stEntity[$foundEntity][] = &$stEntity['__none__'][$stidx];
								array_push($stEntity[$foundEntity],&$stEntity['__none__'][$stidx]);
								unset($stEntity['__none__'][$stidx]);
							}
						}
					}
				}

				// debug("getDataParsed $varname :: $foundEntity");
				$stEntity[$foundEntity] = array();
				$stEntity[$foundEntity][] = &$valor;
				// print_r($stEntity[$foundEntity]);

				// Recorremos la pila, cuyos valores son referencias a distintos puntos de $retval, y hacemos las
				// substituciones pertinentes.
				$stA = NULL;
				while (list($i,$aT) = each($stEntity[$foundEntity])) {
					if (!is_array($stA)) $stA = &$stEntity[$foundEntity][$i];
					$stV = &$stEntity[$foundEntity][$i];
					// $stV = &$stEntity[$foundEntity][$i];
					$bBreak = false;
					$stNext = NULL;
					// print_r($stV);
					while (!$bBreak) {
						// $tmpchk = current($stV);
						if (is_array($stNext) AND sizeof($stNext)) {
							// $bBreak = false;
							$k = array_shift(array_keys($stNext));
							$stV = &$stNext[$k]['item'];
							$aRuta = $stNext[$k]['ruta'];
							// debug("Sacado de la pila, en pos $k campo padre ".$stNext[$k]['campo']);
							// print_r(array_keys($stV));
							// debug("-Ruta-");
							// print_r($aRuta);
							// debug("--");

							unset($stNext[$k]['item']);
							unset($stNext[$k]);
							// array_shift($stNext);
						}
						// debug("tmpchkd: ($tmpchk) array?: ".is_array($stV)." sizeof: ".sizeof($stV));
						// if ( (!is_numeric($tmpchk) AND !$tmpchk) OR !is_array($stV) OR !sizeof($stV)) 
						if ( 
								!is_array($stV) OR !sizeof($stV)
								// OR 
								// (!is_numeric($tmpchk) AND empty($tmpchk)) 
								) 
						{
							// debug("$varname -> Rompiendo porque no hay mas. ");
							break;
						}
						// debug("Empezando con: ");
						// print_r($stV);
						while (list($campo,$aV) = each($stV)) {
							if (!is_numeric($campo)) {
								if (!is_array($aRutaN)) {
									if (!is_array($aRuta)) $aRuta = array($varname); 
									$aRutaN = $aRuta;
								} else array_pop($aRutaN);
								if (is_array($aRutaN) and sizeof($aRutaN)) array_push($aRutaN,$campo);
								// debug("$varname -> campo: $campo  aV array? ".(int)is_array($aV)." Ruta: ");
								// print_r($aRutaN);
								// debug("--");
								$aType = $this->getEntityDataType($foundEntity.'.'.$campo);
								if (!is_array($aType) OR !sizeof($aType)) continue;

								if (!empty($aType['parser_params']) and is_array($aType['parser_params']) and sizeof($aType['parser_params']))
									$aParams = $this->_fetchMethodParams($aType['parser_params']);

								if (empty($aType['parser']) and is_array($this->_aDataFormats[$aType['struct']['type']])) {
									$aFmt = $this->_aDataFormats[$aType['struct']['type']][$aType['struct']['len']];
									if (is_array($aFmt)) $aType = $aFmt;
									else $aType = $this->_aDataFormats[$aType['struct']['type']][0];
								} 

								if (!empty($aType['parser'])) {
									$aF = &$this->_getCallBackMethod($aType['parser']);

									if ($aF) {
										$stV[$campo] = $this->_arrayMapRecursive(&$aF['call'],$stV[$campo],array(&$this,&$aParams,$datasource),NULL,$aRutaN);
										/** **
										if (!is_array($aV)) {
											debug("<b>Riiiiing</b> .. Llamada la funcion X");
											// $stV[$campo] = call_user_func($aF,$stV[$campo],&$this,$aParams);
											$stV[$campo] = $this->_arrayMapRecursive(&$aF,$stV[$campo],array(&$this,&$aParams));
										} else {
											/** 
											for ($k=0;$k<sizeof($stV[$campo]);$k++) {
												$aPS[$k] = &$this;
												$aP[$k] = &$aParams;
											}
											/** **
											// $stV[$campo] = array_map($aF,$stV[$campo],$aPS,$aP);

											debug("<b>Riiiiing</b> .. Llamada al metodo X");
											$stV[$campo] = $this->_arrayMapRecursive(&$aF,$stV[$campo],array(&$this,&$aParams));
										}
										/** **/
									}
								}
								
							} elseif (is_array($aV) AND sizeof($aV)) {
								if (!is_array($stNext)) $stNext = array();
								$i = (array_pop(array_keys($stNext))+1);
								// debug("Almacenando el valor de $campo Claves:> ");
								// print_r(array_keys($stV[$campo]));
								// debug("-$i-");
								$stNext[$i]['item'] = &$stV[$campo];
								$stNext[$i]['campo'] = $campo;
								if (is_array($aRuta)) $stNext[$i]['ruta'] = $aRuta;
								if (!is_array($stNext[$i]['ruta'])) {
									$stNext[$i]['ruta'] = array($varname);
								}
								array_push($stNext[$i]['ruta'],$campo);
								// debug("Almacenando $campo, : ");
								// print_r($stNext[$campo]['ruta']);

									/** **
								if (!is_array($stRuta[$campo])) $stRuta[$campo] = array();
								if (!empty($k)) {
									debug("Insertando, cuando se ha extraido de $k ! ");
									if ($stRuta[$k])
										foreach ($stRuta[$k] as $rval)
											array_push($stRuta[$campo],$rval);
								}
								array_push($stRuta[$campo],$campo);
									/** **/
							}
						}
						$aRutaN = NULL;
						if (is_array($stNext) AND sizeof($stNext)) {
							$bBreak = false;
							// $k = array_shift(array_keys($stNext));
							// $stV = &$stNext[$k];
							// unset($stNext[$k]);
							// array_shift($stNext);

							// if (!empty($k) and is_array($stRuta[$k])) {
								// $stRuta[$k] = NULL;
								// unset($stRuta[$k]);
							// }
							// debug("Resumen de Ruta: ");
							// print_r($stRuta);
						}
						unset($stV);
					}
				}
			}
		} else { // Si no es un vector ...
			$aType = NULL;
			$aType = $this->getEntityDataType($varname);
			if (is_array($aType)) {
				if (!empty($aType['parser_params']) and is_array($aType['parser_params']) and sizeof($aType['parser_params']))
					$aParams = $this->_fetchMethodParams($aType['parser_params']);

				if (empty($aType['parser']) and is_array($this->_aDataFormats[$aType['struct']['type']])) {
					$aFmt = $this->_aDataFormats[$aType['struct']['type']][$aType['struct']['len']];
					if (is_array($aFmt)) $aType = $aFmt;
					else $aType = $this->_aDataFormats[$aType['struct']['type']][0];
				}

				if (!empty($aT['parser'])) {
					if (!empty($aType['parser_params']) and is_array($aType['parser_params']) and sizeof($aType['parser_params']))
						$aParams = $this->_fetchMethodParams($aType['parser_params']);

					$aF = &$this->_getCallBackMethod($aType['parser']);

					if ($aF) {
						$retval = $this->_arrayMapRecursive(&$aF['call'],$valor,array(&$this,&$aParams,$datasource),NULL,array($varname));
						// $retval = call_user_func($aF,$valor,&$this,$aParams);
					}
				} 
			}
		}
		// Fixme: Cachear este resultado. En una variable de tipo INMED
		
		return $retval;
	}

	/**
	  * Metodo de obtencion de la clase css de un dato determinado
	  */
	function getDataCSS($campo) {
		$aDT = $this->getEntityDataType($campo);
		if (!is_array($aDT) OR !sizeof($aDT)) return NULL;
		if (!empty($aDT['data_css']) OR !empty($aDT['label_css'])) {
			$retval = array( 'data' => $aDT['data_css'], 'label' => $aDT['label_css']);
		} elseif (is_array($this->_aDataFormats[$aDT['struct']['type']])) {
			$aFmt = $this->_aDataFormats[$aDT['struct']['type']][$aDT['struct']['len']];
			if (is_array($aFmt)) $aT = $aFmt;
			else $aT = $this->_aDataFormats[$aDT['struct']['type']][0];
			if (!empty($aT['data_css']) OR !empty($aT['label_css'])) {
				$retval = array( 'data' => $aT['data_css'], 'label' => $aT['label_css']);
			}
		}
		return $retval;
	}

	function set_plts () {
		// global $oDb;
		$oDb = $this->get_db ("conf");
		if (!$this->id_secc)
			$this->set_idsecc ();
		$oUsr = $this->get_authed_user ();
		if ((int) $oUsr->authed) {
			$authed = TRUE;
			$usr_mask = $oUsr->get_mask ();
		} else
			$authed = FALSE;
		$modmask = $this->_aModList['mascara'];
		$consulta = "SELECT t1.*,t2.nombre as 'plt_name' ";
		$consulta.= ", t2.pre_code as 'ss_pre_code' ";
		$consulta.= ", t2.post_code as 'ss_post_code' ";
		$consulta.= ", t2.module_mask as 'ss_module_mask' ";
		$consulta.= " FROM ".$this->tb_plantillas." t1, ";
		$consulta.= $this->tb_sub_plts." t2 ";
		$consulta.= " WHERE t2.id_sub=".$this->id_secc;
		$consulta.= " AND t2.id_plt=t1.id_plantilla ";
		if ($authed)
			$consulta.= " AND ( (allow_mask IS NULL OR allow_mask & $usr_mask) AND ".
				" ( deny_mask IS NULL OR !(deny_mask & $usr_mask)) ) ";
		else
			$consulta.= "AND allow_mask IS NULL ";
		if (is_numeric($modmask)) $consulta .= " AND (module_mask IS NULL OR module_mask & $modmask) ";
		$consulta.= " ORDER BY t2.orden";

		$idp = $oDb->query ($consulta);
		$i = $this->plt_point;
		// Ojo... Esto puede dar problemas con el cache?
		if ($oDb->num_rows ($idp)) {
			unset($this->_aPlantillas);
			$this->_aPlantillas = array();
			$this->plantillas = array ();
		} else {
			debug("_no_ hay plantillas. Mal rollito(".$oDb->get_dbase_name()."): $consulta");
		}

		while ($aPlant = $oDb->fetch_array ($idp)) {
			$plt_name = $aPlant["plt_name"];
			$plt_src = $aPlant["nombre"];
			settype($aPlant['ss_module_mask'],'int');

			if (!empty ($aPlant["ss_pre_code"])) $fld = "ss_pre_code";
			else $fld = "pre_code";

// debug("($plt_name,$plt_src) $fld = ".$aPlant[$fld]);
			if (!empty ($aPlant[$fld]) OR strcmp ($aPlant[$fld], "NULL")) {
				$precode = $aPlant[$fld];
			} else {
				$precode = NULL;
			}

			if (!empty ($aPlant["ss_post_code"]))
				$fld = "ss_post_code";
			else
				$fld = "post_code";
			if (!empty ($aPlant[$fld]) OR strcmp ($aPlant[$fld], "NULL")) {
				$postcode = $aPlant[$fld];
			} else {
				$postcode = NULL;
			}
			$argvar = $aPlant['arg_var'];
			if (!strcasecmp ($argvar, "NULL"))
				$argvar = NULL;
			$this->add_plt ($plt_name, $plt_src, 
									array('precode' => $precode, 'postcode' => $postcode, 
											'arg_var' => $argvar, 'module_mask' => $aPlant['ss_module_mask']));

			$i++;
		}
		$oDb->libera ($idp);
	}

	function plt_fwd () {
		return ++$this->plt_point;
	}

	function plt_bkw () {
		return --$this->plt_point;
	}

	/*
	 * esta funcion tendria k llamarse get_arg_var() 
	 */
	function get_key ($plt = "") {
		if (!isset ($plt) OR empty ($plt))
			$plt = $this->plt_point;
// debug("plantilla = ".$this->plantillas[$this->plt_point]);
// aviso("plt = ($plt)");
		$key = $this->plt_arg[$plt];
		// debug("clave = ($key)");
		$aTmpK = split(',',$key);
		$retval = NULL;
		foreach ($aTmpK as $tmpv) {
			$aK = split(':',$tmpv);
			$varname = ( (!empty($aK[1])) ? $aK[1] : $aK[0] ) ;
			$keyname = $aK[0];
			$valor = $this->fetchVar($varname ,'GET');
			if ( (empty($valor) AND !is_numeric($valor)) ) $valor = $this->get_var($varname);
			else $this->set_var($varname,$valor,'SUBSECCION');
			if ( (empty($valor) AND !is_numeric($valor)) ) $valor = $this->fetchVar($varname ,'POST');
			if ( (empty($valor) AND !is_numeric($valor)) ) $valor = $this->fetchVar($varname ,'GLOBAL');
		  // debug("valor de $keyname = (".$valor.")");
			if ( (empty($valor) AND !is_numeric($valor)) ) continue;
			if (!is_array($retval)) $retval = array();
			array_push($retval,array($keyname => $valor));
		}

		if ((empty($retval) AND !is_numeric($retval)) ) return NULL;
		else {
			// debug("retornada clave ");
			return $retval;
		}
	}


	function get_plt_num ($plt) {
		if (empty ($plt))
			return $this->plt_point;
		else {
			$plt_src = $this->plantillas[$plt];
			if (is_int ($plt)) {
				if (!empty ($plt_src))
					return $plt;
				else
					return 0;
			} else {
				if (!empty ($plt_src)) {
					$i = -1;
					foreach ($this->plantillas as $idx => $valor)
						if (is_int ($idx) && !strcmp ($plt_src, $this->plantillas[$idx])) {
							$i = $idx;
							break;
						}
					return $i;
				} else {				  /* No encontramos la plantilla */
					return -1;
				}
			}
		}
	}

	/*
	 * Obtener el nombre de una plantilla a partir de su indice 
	 */
	function get_plt_name ($plt = "") {
		if (empty ($plt))
			$plt = $this->plt_point;

		$plt_src = $this->plantillas[$plt];
//aviso("joer plt_src = $plt_src para plt = $plt");
		if (empty ($plt_src))
			return NULL;

		foreach ($this->plantillas as $clave => $valor) {
//aviso("clave = $clave, valor = $valor");
			if (is_int ($clave))
				continue;
			if (!strcmp ($plt_src, $valor)) {
//aviso("get_plt_name devolemos $clave para plt ($plt)");
				return $clave;
			}
		}
		return NULL;
	}									  // Fin de get_plt_name()

	/*
	 * Obtener el nombre de una plantilla a partir de su indice 
	 */
	function get_plt_array ($plt = "") {
		if (empty ($plt))
			$plt = $this->plt_point;

		$plt_src = $this->plantillas[$plt];
// debug("joer plt_src = $plt_src para plt = $plt");
		if (empty ($plt_src))
			return NULL;
//debug("PLANTILLAS:");
//depurar_array($this->code);
		foreach ($this->plantillas as $clave => $valor) {
//debug("clave = $clave, valor = $valor");
			if (is_int ($clave))
				continue;
			if (!strcmp ($plt_src, $valor)) {
//debug("get_plt_name devolemos $clave para plt ($plt) Nº(".$this->code[$clave][0].")");
				return array ($clave, $valor, $this->code[$clave][0]);
				// return array($clave,$valor,$this->code[$this->get_plt_num($clave)][0]);
				// return array($clave,$valor);
			}
		}
		return NULL;
	}									  // Fin de get_plt_name()

	function getPltArray ($plt = NULL) {
		if (empty ($plt)) $plt = $this->get_plt_name($this->plt_point);
		return $this->_aPlantillas[$plt];
	}									  // Fin de get_plt_name()

/** Retorna un array  de array formados por nombre puunto de informacion  , nombre de la plantilla , nombre del precode de la subseccion actual 
*/
	function get_plt_array_all () {
		foreach ($this->plantillas as $clave => $valor) {
			if (!is_int ($clave)) {
				// $aRetVal[] = $this->_aPlantillas[$clave];
				$aRetVal[] = 
					array ($clave, $valor, $this->code[$this->get_plt_num ($clave)][0], $this->code[$this->get_plt_num ($clave)][1]);
			}
		}
		return $aRetVal;

	}									  // Fin de get_plt_name()

	function getPltArrayAll() {
		return $this->_aPlantillas;
	}

	function delPlt($plt) {
		if (empty ($plt)) $plt = $this->get_plt_name($this->plt_point);
		if (is_object($this->_aPlantillas[$plt]['oRoot'])) unset($this->_aPlantillas[$plt]['oRoot']);
		$this->_aPlantillas[$plt] = NULL;
		unset($this->_aPlantillas[$plt]);
		// Sist Tradicional:
		$num = $this->get_plt_num($plt);
		$this->plantillas[$num] = NULL;
		unset($this->plantillas[$num]);
		$this->plantillas[$plt] = NULL;
		unset($this->plantillas[$plt]);
		$this->code[$plt] = NULL;
		unset($this->code[$plt]);
		$this->plt_arg[$plt] = NULL;
		unset($this->plt_arg[$plt]);
	}

	function reset_plts () {
		$this->plantillas = array ();
		unset($this->_aPlantillas);
		$this->_aPlantillas = array();
		$this->code = array ();
		$this->plt_arg = array ();
		$this->plt_point = 0;
		$this->plt_point_end = 0;
		$this->plt_name = NULL;
		return 1;
	}

	function change_plt ($plt, $src) {
		if (empty ($this->plantillas[$plt]))
			return 0;
		$num = $this->get_plt_num ($plt);
		if ($num == -1)
			return 0;
		$this->plantillas[$num] = $src;
		$this->plantillas[$plt] = $src;
//debug("change_plt($plt,$src)");
		// $this->code[$num][0] = NULL;
		// $this->code[$plt][0] = NULL;
		/*
		 * parche 
		 */
//                        $this->old_secc_name = NULL;
		return 1;
	}

	function changePlt($plt,$aP) {
		if (!is_array($aP) or !sizeof($aP)) return false;
		if (!is_array($this->_aPlantillas[$plt])) return false;
		foreach ($aP as $k => $v) if (isset($this->_aPlantillas[$plt][$k])) $this->_aPlantillas[$plt][$k] = $v;

		$nplt = $this->get_plt_num($plt);
		if (!empty($aP['src'])) {
			$this->plantillas[$plt] = $aP['src'];
			$this->plantillas[$nplt] = $aP['src'];
		}
		if (isset($aP['precode'])) {
			$this->code[$plt][0] = $aP['precode'];
			$this->code[$nplt][0] = $aP['precode'];
		}
		if (isset($aP['postcode'])) {
			$this->code[$plt][1] = $aP['postcode'];
			$this->code[$nplt][1] = $aP['postcode'];
		}
		if (isset($aP['arg_var'])) {
			$this->plt_arg[$plt] = $aP['arg_var'];
			$this->plt_arg[$nplt] = $aP['arg_var'];
		}
	}

	/*
	 * Este metodo cambia el precode de una plantilla a NULL plt - puntero a la plantilla (o punto de informacion) 
	 */
	function reset_plt_precode ($plt) {
//debug("plt: $plt");
		if (empty ($this->plantillas[$plt]))
			return 0;
		$num = $this->get_plt_num ($plt);
		if ($num == -1)
			return 0;
		$this->code[$num][0] = NULL;
		$this->code[$plt][0] = NULL;
		return 1;
	}

	/*
	 * Este metodo cambia el precode de una plantilla: plt - puntero a la plantilla src - fichero.ext nuevo precode - precode()
	 * nuevo 
	 */
	function change_plt_precode ($plt, $src, $precode = NULL, $postcode = NULL, $argvar = NULL) {
		if (empty ($this->plantillas[$plt]))
			return 0;
		$num = $this->get_plt_num ($plt);
		if ($num == -1)
			return 0;
		if (!empty($src)) {
			$this->plantillas[$num] = $src;
			$this->plantillas[$plt] = $src;
		}
		if (!empty($precode)) $this->code[$num][0] = $precode;
		if (!empty($postcode)) $this->code[$num][1] = $postcode;
		if ($this->debug)
			debug ("wolSesion->change_plt_precode($plt,$src) ..");
		if ($argvar == -1)
			$this->plt_arg[$num] = NULL;
		elseif ($argvar) $this->plt_arg[$num] = NULL;
		return 1;
	}

	/*
	 * Metodo para añadir una plantilla al array de plantillas 
	 */
	function add_plt ($plt, $src, $precode = NULL, $postcode = NULL, $arg_var = NULL) {
		if (is_array($precode) and sizeof($precode)) {
			if (!empty($precode['postcode']) and empty($postcode)) $postcode = $precode['postcode'];
			if (!empty($precode['arg_var']) and empty($arg_var)) $arg_var = $precode['arg_var'];
			if (is_numeric($precode['module_mask'])) $module_mask = $precode['module_mask'];
			$precode = $precode['precode'];
		}
		if ($this->debug)
			debug ("wolSesion->add_plt($plt,$src,$precode,$postcode,$arg_var)  :: ".$this->plt_point_end);
		if (empty ($src) OR empty ($plt))
			return -1;
		if ($this->get_plt_num ($plt) != -1) {
			if ($this->debug)
				debug ("PII Ya existia, no se anyade nada");
			return -1;
		}
		$this->plantillas[$this->plt_point_end++] = $src;
		if (!is_int ($plt)) {
			$this->_aPlantillas[$plt] = 
					array('pii' => $plt, 'src' => $src, 'precode' => $precode, 
							'postcode' => $postcode, 'arg_var' => $arg_var, 'module_mask' => $module_mask);
			$this->plantillas[$plt] = $src;
			if (!empty ($precode))
				$this->code[$plt][0] = $precode;
			if (!empty ($postcode))
				$this->code[$plt][1] = $postcode;
			if (!empty ($arg_var))
				$this->plt_arg[$plt] = $arg_var;
		}
		if ($precode)
			$this->code[$this->plt_point_end - 1][0] = $precode;
		if ($postcode)
			$this->code[$this->plt_point_end - 1][1] = $postcode;
		if ($arg_var)
			$this->plt_arg[$this->plt_point_end - 1] = $arg_var;

		return ($this->plt_point_end - 1);
	}

	/** Funcion que nos devuelve cual es la siguiente plantilla a inter
     pretar por esta funcion.
         OJITO! Esta funcion modifica el puntero de plantillas. grrrr        **/
	function get_plt ($plt) {
		// debug("next_plt.plt_point(".$this->plt_point.") ($plt)");
		$printvar='imprimir';
		if (empty ($plt)) {
			// Si existe el parametro de impresion, es el primero que ponemos.
			$bPrint = (bool)$this->fetchVar('imprimir','GET POST');
			if ($bPrint and is_array($this->_aPlantillas['prettyPrint']) and sizeof($this->_aPlantillas['prettyPrint'])) {
				$plt = 'prettyPrint';
				$this->plt_point = $this->get_plt_num($plt);
			}
			if (empty($plt)) {
				foreach ($this->plantillas as $idx => $src)
					if (is_int ($idx)) {
						$this->plt_point = $idx;
						break;
					}
				$plt = $this->plt_point;
			}
		} else {
			if (is_int ($plt)) {
				$pltn = $plt;
				$bPrint = (bool)$this->fetchVar('imprimir','GET POST');
				if ($bPrint and is_array($this->_aPlantillas['prettyPrint']) and sizeof($this->_aPlantillas['prettyPrint'])) {
					$plt = 'prettyPrint';
					$pltn = $this->get_plt_num($plt);
				}
				$plt_src = $this->plantillas[$plt];
				if (!empty ($plt_src)) $this->plt_point = $pltn;
				else $this->plt_point = 0;
				$this->plt_name = NULL;	/* Documentar! */
			} else {
				// Plantillas especiales obtenidas de configuracion
				if (!strcmp('::',substr($plt,0,2))) {
					$tmp = substr($plt,2);
					$aPlt = split(':',$tmp);
					if (!strcasecmp($aPlt[0],'pltcfg')) {
						if (is_array($this->_aCfgPlts[$aPlt[1]])) {
							$aRetPlt = $this->_aCfgPlts[$aPlt[1]];
						} else $aRetPlt = $this->_aCfgPlts['null'];
						if (is_array($aRetPlt)) return $aRetPlt['nombre'];
						else return NULL;
					}
				} else { // Plantillas obtenidas de las posibles de esta subseccion.
					$plt_src = $this->plantillas[$plt];
					if (!empty ($plt_src)) {
						$nPlts = -1;
						foreach ($this->plantillas as $idx => $src)
							if (is_numeric ($idx) AND ! strcmp ($plt_src, $src)) {
								// debug("Encontrado!! ($plt_src - $i - $plt) ");
								$nPlts = (int) $idx;
								break;
							}
						if ($nPlts == -1) {
							$this->errores ("Referencias incoherentes en los Indices de Plantillas");
							exit;
						} else {
							$this->plt_point = $nPlts;
							$this->plt_name = $plt;
						}
					} else {				  /* No encontramos la plantilla */
						if (!is_array ($this->_aCfgPlts['null'])) {
							$this->errores ("No he encontrado la plantilla ($plt)");
	//aviso("puntero = ".$this->plt_point);
	//aviso("plantillas = ".sizeof($this->plantillas));
							exit;
						} else {
							return $this->_aCfgPlts['null']['nombre'];
						}
					}
				}
			}
		}

// debug("Retonno($plt): ".$this->plantillas[$plt]);
		// if ($plt != -1) {
		return $this->plantillas[$plt];
		// } else { return; }
	}

	function storeRootBlock(&$oBucle) {
		$pname = $this->get_plt_name();
		$retval = false;
		if (is_object($oBucle) and is_array($this->_aPlantillas[$pname]) and sizeof($this->_aPlantillas[$pname])) {
			$this->_aPlantillas[$pname]['oRoot'] = &$oBucle;
			$retval = true;
		}
		return $retval;
	}

	function &getRootBlock($pname = NULL) {
		if (empty($pname)) $pname = $this->get_plt_name();

		if (is_array($this->_aPlantillas[$pname]) and sizeof($this->_aPlantillas[$pname])) {
			// debug("getRootBlock($pname)");
			return $this->_aPlantillas[$pname]['oRoot'];
		} else return NULL;
	}


					 /*** EJECUCION de codigo de las Plantillas ***/

	function activeModuleCall($methodname,$aP = NULL,$plt = NULL) {
		$aRVal = array();
		if (is_array($this->_aActiveModules) and sizeof($this->_aActiveModules) and (empty($plt) or (is_array($this->_aPlantillas[$plt])
				and sizeof($this->_aPlantillas[$plt]) and is_numeric($this->_aPlantillas[$plt]['module_mask']))) ) {
			foreach ($this->_aActiveModules as $modname)
				if (empty($plt) or ( (($this->_aModulos[$modname]['mascara']) & ($this->_aPlantillas[$plt]['module_mask'])) ) ) 
					if (is_object($this->_aModList[$modname]) and method_exists($this->_aModList[$modname],$methodname)) {
						/** **
						debug("Vamos a llamar al $modname :: $methodname () por que la mascara de ($plt)(".$this->_aPlantillas[$plt]['module_mask'].
								") coincide con ".$this->_aModulos[$modname]['mascara']." Verdad=? ".
								(($this->_aModulos[$modname]['mascara']) & ($this->_aPlantillas[$plt]['module_mask'])) );
						/** **/
						// $aRVal[$modname] = $this->_aModList[$modname]->$methodname($aP[0],$aP[1],$aP[2],$aP[3],$aP[4]);
						$rval = call_user_func_array(array(&$this->_aModList[$modname],$methodname),$aP);
						if (!is_null($rval)) $aRVal[$modname] = $rval;
					}
		}
		if (!sizeof($aRVal)) return NULL;
		else return $aRVal;
	}

	function exec_plt ($plt = NULL) {
		$realname = $this->get_plt_name($plt);
		if (!is_numeric($plt) and !is_array($this->_aPlantillas[$realname])) return NULL;
		$aTmp = $this->activeModuleCall('triggerPII',array($realname),$realname);
		if (is_array($aTmp) and sizeof($aTmp))
			foreach ($aTmp as $p) 
				if (!empty($p) and !is_bool($p)) {
					$pname = $p;
					break;
				}
		if (!empty($pname)) {
			$plt_retorno = $this->_aPlantillas[$plt]['src'];
		}

		if (empty ($plt)) {
			$plt = $this->get_plt_name ($this->plt_point);
			$func = $this->code[$plt][0];
		} else {
			// Plantillas especiales obtenidas de configuracion
			if (!strcmp('::',substr($plt,0,2))) {
				$tmp = substr($plt,2);
				$aPlt = split(':',$tmp);
				if (!strcasecmp($aPlt[0],'pltcfg')) {
					if (is_array($this->_aCfgPlts[$aPlt[1]])) {
						$aRetPlt = $this->_aCfgPlts[$aPlt[1]];
					} else $aRetPlt = $this->_aCfgPlts['null'];
					if (is_array($aRetPlt)) $func = $aRetPlt['pre_code'];
					else $func = NULL;
				}
			} else {
				$func = $this->code[$plt][0];
			}
		}

		if (!empty ($func)) {
			if ($this->debug & DBUG_INC) debug("exec_plt($plt) : $func ");
			$aF = &$this->_getCallBackMethod($func);
			if ($aF) $plantilla = call_user_func(&$aF['call'],&$this);
		}

		if (!empty($plantilla)) $plt_retorno = $plantilla;
		else {
			$plt_num = $this->get_plt_num($plt);
			if ($this->oMsgs->haveCode(IM_FATALERROR) AND !empty($func)) {
				// Si es la plantilla base la que 'casco' se lanza la plt full de errores
				if (empty($plt_num)) {
					$plt_retorno = $this->_aCfgPlts['err_full']['nombre'];
					if (!empty($this->_aCfgPlts['err_full']['pre_code'])) {
						$aF = &$this->_getCallBackMethod($this->_aCfgPlts['err_full']['pre_code']);
						if ($aF) call_user_func(&$aF['call'],&$this);
					}
					// $plt_link = 'LOGOUT';
				} else {
					$plt_retorno = $this->_aCfgPlts['err_pii']['nombre'];
					if (!empty($this->_aCfgPlts['err_pii']['pre_code'])) {
						$aF = &$this->_getCallBackMethod($this->_aCfgPlts['err_pii']['pre_code']);
						if ($aF) call_user_func(&$aF['call'],&$this);
					}
				}
				if (!empty($plt_retorno)) {
					//debug("link $plt_link");
					$this->perror_link($plt_link);
				}
			}
		}
		return $plt_retorno;
	}

					 /*** cebadores de DATOS a las PLANTILLAS ***/

					 /** Indica al motor de plantillas si ha de hacer la query(1) o no(0) */
	function do_query ($plt_name = "") {
		if (!isset ($plt_name) OR empty ($plt_name)) {
			if (!empty ($this->plt_name))
				$plt_name = $this->plt_name;
			else
				$plt_name = $this->get_plt_name ($this->plt_point);
			if ($this->debug & DBUG_MODS)
				debug ("1 do_query de $plt_name (".$this->hay_b.") (".$this->hay_menu.")");
		}
		if ((!is_object ($this->b_activa) OR ! $this->hay_b) AND (!is_object ($this->menu) OR ! $this->hay_menu)) {
			if ($this->debug & DBUG_MODS)
				debug ("do_query de $plt_name");
			return 1;
		}
		if ($this->hay_b AND $val = (int) ($this->b_activa->reconocer_plt ($plt_name))) {
			if ($this->debug & DBUG_MODS)
				debug ("el buscador ha reconocido $plt_name ($val)");
			return !$val;
		}
		elseif ($this->hay_menu AND $val = (int) ($this->menu->reconocer_plt ($plt_name)))
			return !$val;
		else return 1;
	}

	function reconocer_bloque ($bloque) {
		if ($this->hay_b)
			return $this->b_activa->reconocer_bloque ($bloque);
		return 0;
	}


			/** Obtiene el siguiente array de datos para un bucle de plantilla **/
	function get_plt_data ($bName = "") {
//salida("bname $bName <BR>\n");
		if (!isset ($bName) OR empty ($bName))
			$bName = "exterior";
		if (is_object ($this->menu) AND $this->hay_menu) {
//salida("get_plt de menu");
			$RetVal = $this->menu->get_plt_data ($bName);
//salida("menu ha devuerto tantos como ".sizeof($RetVal)."<BR>\n");
		} else
			$RetVal = array ();

		if (!$RetVal AND is_object ($this->b_activa) AND $this->hay_b) {
//salida("get_plt de buscador<BR>\n");
			$RetVal = $this->b_activa->get_plt_data ($this, $bName);
		}
		if (!sizeof ($RetVal))
			$RetVal = array ();

/*
salida("(get_plt_data) retval: ".sizeof($RetVal)."<BR>\n");
for (;list($a,$b) = each($RetVal);) {
salida(" $a  $b <BR>\n");
}
reset($RetVal);
*/
		return $RetVal;
	}

	/** documentar tb *
          Añadir parametros a una busqueda.
                */
	function set_query_param ($type, $val) {
		$retval = 1;
		if ($this->hay_b AND !empty($type) AND !empty($val)) {
			$retval = $this->b_activa->set_param_query ($type, $val);
		}
		return $retval;
	}

	function hay_rows () {
		$val = -1;
		if ($this->hay_b)
			$val = $this->b_activa->hay_rows ();
		if ($val != -1)
			return $val;
		elseif ($this->hay_menu) {
			$val = $this->menu->hay_rows ();
			if ($val == -1)
				$val = 0;			  /* ultimo, si no la reconoce.  a la shit */
			return $val;
		}
		else
		return 0;
	}


					 /**** soporte para MODULOS *****/
	function load_internal_modules () {
		$cons = "SELECT * FROM ".$this->tb_modulos." WHERE base=1";
		$this->query ($cons);
	}

	 /**** soporte para MODULOS *****/

/**
        * PLT_???? (al salir de la plantilla)
        * NOEXPIRE (obivio)
        * INMED (al cerrar la sesion)
        * SUBSECCION (al cambiar de subseccion)
        */
	function set_var ($var_name, $value, $expire = NULL) {
		// if (!strcmp ($expire, "EXPIRE")) $expire = "INMED";

		if (is_object ($value) AND $this->check_class_module (get_class ($value))) {
			if ($this->debug & (DBUG_VARS | DBUG_MODS))
				debug ("set_var($var_name, Objeto de Clase ,$expire) - ".get_class($value));
			$this->_aClasses[$var_name][0] = $value;
			if (!isset($this->_aClasses[$var_name][1])) $this->_aClasses[$var_name][1] = ( (!empty($expire)) ? $expire : 'NOEXPIRE' );
			$this->_aClasses[$var_name][2] = time (NULL);
		} else {
			if ($this->debug & DBUG_VARS) 
				debug ("<b>set_var</b>($var_name,$value,$expire)");
			$this->aData[$var_name][0] = $value;
			if (!isset($this->aData[$var_name][1])) $this->aData[$var_name][1] = ( (!empty($expire)) ? $expire : 'NOEXPIRE' );
			$this->aData[$var_name][2] = time (NULL);
		}
	}

	function get_var ($var_name) {
		if (is_array ($this->_aClasses[$var_name])) {
			if (is_array ($this->aData[$var_name])) debug("Error: Existe _TAMBIEN_ la variable NO de Objeto $var_name ");
			if (($this->debug & (DBUG_VARS | DBUG_MODS)))
				debug ("get_-object-_var($var_name) =>".$this->_aClasses[$var_name][0]);
			return $this->_aClasses[$var_name][0];
		} elseif (is_array ($this->aData[$var_name])) {
			if (($this->debug & DBUG_VARS))
				debug ("get_var($var_name) =>".$this->aData[$var_name][0]);
			return $this->aData[$var_name][0];
		}
		return NULL;
	}

	function setVarByRef ($var_name, &$value, $expire = NULL) {
		// if (!strcmp ($expire, "EXPIRE")) $expire = "INMED";

		if (is_object ($value) AND $this->check_class_module (get_class ($value))) {
			if ($this->debug & (DBUG_VARS | DBUG_MODS))
				debug ("set_var($var_name, Objeto de Clase ,$expire) - ".get_class($value));
			$this->_aClasses[$var_name][0] = &$value;
			if (!isset($this->_aClasses[$var_name][1])) $this->_aClasses[$var_name][1] = ( (!empty($expire)) ? $expire : 'NOEXPIRE' );
			$this->_aClasses[$var_name][2] = time (NULL);
		} else {
			if ($this->debug & DBUG_VARS) 
				debug ("<b>set_var</b>($var_name,$value,$expire)");
			$this->aData[$var_name][0] = &$value;
			if (!isset($this->aData[$var_name][1])) $this->aData[$var_name][1] = ( (!empty($expire)) ? $expire : 'NOEXPIRE' );
			$this->aData[$var_name][2] = time (NULL);
		}
	}

	function &getVarByRef ($var_name) {
		if (is_array ($this->_aClasses[$var_name])) {
			if (is_array ($this->aData[$var_name])) debug("Error: Existe _TAMBIEN_ la variable NO de Objeto $var_name ");
			if (($this->debug & (DBUG_VARS | DBUG_MODS)))
				debug ("get_-object-_var($var_name) =>".$this->_aClasses[$var_name][0]);
			return $this->_aClasses[$var_name][0];
		} elseif (is_array ($this->aData[$var_name])) {
			if (($this->debug & DBUG_VARS))
				debug ("get_var($var_name) =>".$this->aData[$var_name][0]);
			return $this->aData[$var_name][0];
		}
		return NULL;
	}

	function fetchVar($var_name,$origtype = NULL, $bCheckSums = TRUE,$formatname = NULL) {
		static $aActvar = array();
		if (empty($var_name)) return NULL;

		if (empty($origtype)) {
			$regglobals = $this->_getKrnCfg('register_globals');
			if ($regglobals) $aType = array('GET');
			else $aType = array('GLOBAL');
		} else $aType = split(' ',$origtype);

		$bFormat = true;
		if ($formatname=='__none__') $bFormat = false;
		elseif (in_array($var_name,$aActvar)) $bFormat = false;
		array_push($aActvar,$var_name); // Para evitar bucles si getDataParsed y anidamientos llama otra vez a fetchVar
		// debug("actvar: ");
		// print_r($aActvar);

		foreach ($aType as $type) {
			switch ($type) {
				case 'GET':
					$retval = $_GET[$var_name];
					if ( (!empty($retval) or is_numeric($retval)) and $bFormat )
						$retval = $this->getDataParsed( $var_name ,$retval, ((!empty($formatname)) ? $formatname : NULL),'GET');
					break;

				case 'POST':
					$retval = $_POST[$var_name];
					if ( (!empty($retval) or is_numeric($retval)) and $bFormat ) {
						$retval = $this->getDataParsed( $var_name ,$retval, ((!empty($formatname)) ? $formatname : NULL),'POST');
					}
					break;

				case 'REQUEST':
					$retval = $_REQUEST[$var_name];
					break;

				case 'GLOBAL':
					$retval = $GLOBALS[$var_name];
					break;

				case 'SESSION':
					$retval = $this->get_var($var_name);
					break;

				default:
					break;
				// Por defecto de ..  $retval = $GLOBALS['_GET'][$var_name];
			}
			if (!empty($retval) OR is_numeric($retval)) break;
		}
		if ($bFormat) $aActvar = array();

		if (is_array($retval) ANd $bCheckSums) {
			$keys = implode('',array_keys($retval));
			$crc_keys = crc32($keys);
			$values = implode_r(NULL,$retval);
			$crc_values = crc32($values);

			if (!is_array($this->_aCrcCheck[$var_name])) {
				$this->_aCrcCheck[$var_name] = array();
				$this->_aCrcCheck[$var_name]['status_last'] = IKRN_VAR_CRC_NEW;
			} else {
				$this->_aCrcCheck[$var_name]['status_last'] = 0;
				if ($this->_aCrcCheck[$var_name]['crckeys'] == $crc_keys) 
					$this->_aCrcCheck[$var_name]['status_last'] |= IKRN_VAR_CRC_KEYMATCH;
				if ($this->_aCrcCheck[$var_name]['crcvalues'] == $crc_values) 
					$this->_aCrcCheck[$var_name]['status_last'] |= IKRN_VAR_CRC_VALUEMATCH;

				if (empty($this->_aCrcCheck[$var_name]['status_last'])) {
					$this->_aCrcCheck[$var_name]['status_last'] = IKRN_VAR_CRC_CHANGE;
				}
			}
			$this->_aCrcCheck[$var_name]['crckeys'] = $crc_keys;
			$this->_aCrcCheck[$var_name]['crcvalues'] = $crc_values;
			
		}

		return $retval;
	}

	function verifyVar($var_name, $check = IKRN_VAR_CRC_CHANGE) {

		return TRUE;
		if (!is_numeric($check)) return FALSE;
		if ($check & IKRN_VAR_CRC_AUTHED) return TRUE;

		if (!is_array($this->_aCrcCheck[$var_name]) OR 
				!is_numeric($this->_aCrcCheck[$var_name]['status_last'])) {
			// Este caso no se produce dado que fetchVar asigna un IKRN_VAR_CRC_NEW y crea el array de la variable si no existe.
			if ( (($check & IKRN_VAR_CRC_CHANGE) OR ($check & IKRN_VAR_CRC_NEW)) 
					AND (is_array($this->_aCrcCheck[$var_name])) ) return TRUE;
			else return FALSE;
		}

		$bRetval = FALSE;
		if ($check & IKRN_VAR_CRC_CHANGE) {
			// debug("checking: Cambio de crc ... ".($this->aCrcCheck[$var_name]['status_last'] & ~IKRN_VAR_CRC_VALUEMATCH));
			// debug("st: ".decbin($this->_aCrcCheck[$var_name]['status_last'])." chk: ".decbin(~IKRN_VAR_CRC_VALUEMATCH));
			if ($this->_aCrcCheck[$var_name]['status_last'] & IKRN_VAR_CRC_NEW) return TRUE;
			elseif ($this->_aCrcCheck[$var_name]['status_last'] & IKRN_VAR_CRC_VALUEMATCH) return FALSE;		// Si los valores coinciden, no hay cambio
			elseif ($this->_aCrcCheck[$var_name]['status_last'] & ~IKRN_VAR_CRC_VALUEMATCH) return TRUE;		// Si hay alguna otra marca, hay cambio (generoso)
			else return FALSE;
		} 

		if ($this->_aCrcCheck[$var_name]['status_last'] & $check) return TRUE;
		else return FALSE;
	}

	function unset_vars ($type) {
		if ($this->debug & DBUG_VARS)
			debug ("unset_vars($type)");
		if (is_array ($this->aData))
			foreach ($this->aData as $clave => $valor)
				if (!strcmp ($valor[1], $type))
					$this->unset_var ($clave);
		if (is_array ($this->_aClasses))
			foreach ($this->_aClasses as $clave => $valor)
				if (!strcmp ($valor[1], $type))
					$this->unset_var ($clave, 1);
	}

	/** 
	  * Elimina una variable de la sesion. El tipo es 0 - Normal; 1 - Objeto de un Modulo
	  **/
	function unset_var ($var_name, $type = 0) {
		if (!$type) {
			if (!is_array($this->aData[$var_name])) $type = 1;
			else {
				if ($this->debug & DBUG_VARS) debug ("unset_var($var_name)");
				$this->aData[$var_name][0] = NULL;
				$this->aData[$var_name][1] = NULL;
				unset ($this->aData[$var_name]);
			}
		}
		if ($type) {
			if (is_array ($this->_aClasses[$var_name])) {
				if ($this->debug & DBUG_VARS) debug ("unset_var($var_name) -> Object :: ".get_class($this->_aClasses[$var_name][0]));
				$this->_aClasses[$var_name][0] = NULL;
				$this->_aClasses[$var_name][1] = NULL;
				unset ($this->_aClasses[$var_name]);
				// debug("$var_name unsetted y tal (".$this->_aClasses[$var_name].")");
			}
		}
		return;
	}

					 /**** ERRORES y CERRAR ****/

	function lcMessage($sErr,$aErrParams = NULL,$iType = NULL) {
		return $this->oMsgs->addMsg($sErr,$aErrParams,$iType);
	}

	function &getMsgs() {
		return $this->oMsgs;
	}

	function perror_link($lnk = 'BACK') {
		$errlink = $this->get_var('__error_return_link');
		if (!empty($errlink)) return ; // SI ya esta setteado, nada.

		if ($lnk == 'BACK') {
			$pss = $this->get_old_subsecc_name();
			if (!empty($pss)) $link = '?seccion='.$pss;
			else $link = '?logout=1';
		} elseif ($lnk == 'LOGOUT') {
			$link = '?logout=1';
		} elseif ($lnk == 'HOME') {
			debug("Falta por configurar el enlace a _home_");
			$link = '?logout=1';
		} elseif ($lnk == 'SECCION') {
			$link = '?seccion='.$this->get_section_name();
		} else $link = $lnk;
		$this->set_var('__error_return_link',$link,'INMED');
	}

	function cerrar () {
		/** Antes de cerrar la sesion renderizamos su contenido **/
		plantillas (&$this);
		/** soporte email **/
		$aMod = $this->_getStdOutMod();
		if (is_array($aMod)) {
			if (function_exists($aMod['finish'])) $aMod['finish']($this);
		}
		/** **/
		$this->_aActiveModules = array();
		$this->unload_modules ();
		$this->quit ();
	}

	function quit () {
		if ($this->debug & DBUG_DB)
			debug ("Callin quit()");

		if (is_object ($this->Access))
			$this->Access->cerrar ();

		if (is_array($this->_aPlantillas) and sizeof($this->_aPlantillas))
			foreach (array_keys($this->_aPlantillas) as $pname)
				if (is_object($this->_aPlantillas[$pname]['oRoot']))
					unset($this->_aPlantillas[$pname]['oRoot']);
			 /** 
       $func = $this->code[$this->plt_point][1]; /* post_code esto en plts *
       if (!empty($func)) return $func($this);
			 **/

								 /** Mandamos senyal de cierre a todos los modulos **/
		// debug("y b_activa?");
		// print_r(is_object($this->b_activa));
		if (is_object ($this->b_activa))
			$this->b_activa->cerrar ();
		if (is_object ($this->menu))
			$this->menu->cerrar ();


		if (is_object ($this->db)) {
			debug("Cerrando instancia obsoleta wolSession::db ");
			$this->db->cerrar ();
		}

								 /** Preparamos los punteros para ser guardados **/
		$this->plt_point = 0;

		// Reservamos la db-conf para la ultima en cerrar
		// unset($this->dbs);

		$this->unset_vars ("INMED");
				
		$this->_aEntityList = $this->_aCurEntityList;

		$this->oMsgs->cerrar();

		$oDbCfg = &$this->get_db('conf');
		$ssact = $this->get_subsecc_name();
		// debug("Guardamos la sesion... ".$ssact." es igual que ".$this->Access->aConf['sub_seccion']." ? ");
		if ($ssact != $this->Access->aConf['sub_seccion']) {
			$bUpdate = $this->getFromKrn('recovered_session');
			$sId = session_id();
			$id_usr = $this->get_user();
			// debug("Almacenando la sesion $sId ");
			if ($bUpdate) {
				 // debug("actualizando la vez $sId ");
				$oDbCfg->tb_update('Users_sessions',array('sessid' => $sId, 'app_name' => $this->App_Name, 'id_usr' => $id_usr, 'valor' => serialize($this) ));
			} else {
				// debug("por primera vez $sId ");
				$oDbCfg->tb_replace('Users_sessions',array('sessid' => $sId, 'app_name' => $this->App_Name, 'id_usr' => $id_usr, 
											'alta' => date('Y-m-d H:i:s'), 'valor' => serialize($this) ));
			}
		}
		$this->set_db('conf',&$oDbCfg,true);
		$GLOBALS['INMERSA_BASEDB'] = &$oDbCfg;
		if (!session_register ('INMERSA_BASEDB'))	/* cambiar por $this->error() */
			salida ("ERROR Interno, no se ha podido guardar la sesion.<BR>\n");

		$this->cerrar_dbs();
		$this->restore_dbpoint ();

				 /** Guardamos el objeto en la sesion **/
		// if (!session_register ($this->obj_var_name))	/* cambiar por $this->error() */
			// salida ("ERROR Interno, no se ha podido guardar la sesion.<BR>\n");
		// exit;
		/*
		 */
//debug("Cerramos la sesion($this->obj_var_name)! con nombre ".session_name()."(".session_id().")");
		// session_write_close();

		return;
	}

// Funciones Obsoletas:
	function errores ($msg = "Error") {
		aviso ("Error(Sesion) : $msg");
		return;
	}

	function perror ($code = 0, $where = NULL, $what = NULL) {
		$aErrMsg = $this->get_var ('_elementos_fail');
		if (!is_array ($aErrMsg))
			$aErrMsg = array ();
		$aErr['campo'] = $where;
		$aErr['campo_msg'] = $what;
		array_push ($aErrMsg, $aErr);
		$this->set_var ("_elementos_fail", $aErrMsg, "INMED");
	}

	function perror_plt ($link = NULL) {
		if (!$link)
			$link = "javascript: history.go(-1);";
		$this->set_var ('__error_return_link', $link, "INMED");
		return "errores.plt";
	}

	function AllowedLink($aParam) {
		if (!is_array($aParam)) return false;
		$sub = array_shift($aParam);
		if (empty($sub)) return 1;
		$aSubGrants = $this->get_var("_aSubsecGrants");
		if (!is_array($aSubGrants) OR !is_numeric($aSubGrants[$sub])) {
			$db_conf = $this->get_db('conf');
			$retval = $this->_VerifyLinkGrants($sub);
			$aSubGrants[$sub] = (int)$retval;
			$this->set_var("_aSubsecGrants",$aSubGrants,"NOEXPIRE");
		} else $retval = $aSubGrants[$sub];
		return $retval;
	}

	function _VerifyLinkGrants($link) {
		$oUsr = $this->get_authed_user();
		$oDb = &$this->get_db('conf');
		if (!is_object($oDb)) return -1;
		$mask = $oUsr->get_mask();
		$modmask = $this->_aModList['mascara'];
		$cons = "SELECT t1.id_seccion ".
					"FROM Sec_Subsecc t1, Sub_Secc t2, Secciones t3 ".
					"WHERE t1.id_sub_secc = t2.id_sub_secc AND t3.id_seccion = t1.id_seccion AND ".
					"(t2.nombre = '$link' OR t3.nombre = '$link') AND ".
					"(t1.av_group & $mask OR (t1.av_group IS NULL AND t3.av_mask & $mask)) ".
					( (is_numeric($modmask)) ? "AND (t2.module_mask & $modmask) " : "");
		$rs = $oDb->query($cons);
		if ($oDb->num_rows($rs)) $retval = 1;
		else $retval = 0;
		$oDb->libera($rs);

		return $retval;
	}

	function AllowedPII($aParam) {
		$retval = true;
		if (!is_array($aParam) OR !sizeof($aParam)) return false;
		$pii = array_shift($aParam);
		$aPii = $this->get_plt_array($pii);
		if (!is_array($aPii) OR !sizeof($aPii)) return false;
		return true;
	}

	function AllowedAction($aParam) {
		$ent = array_shift($aParam);
		$acc = array_shift($aParam);

		$control = (int)$this->getFromKrn('action_access');
		if ($control AND (empty($ent) OR empty($acc)) ) return false;
		elseif (empty($ent) OR empty($acc)) return true;

		if (!strcasecmp($acc,'new') OR !strcasecmp($acc,'nuevo')) $tipo='NEW';
		elseif (!strcasecmp($acc,'edit') OR !strcasecmp($acc,'editar')) $tipo='EDIT';
		elseif (!strcasecmp($acc,'del') OR !strcasecmp($acc,'borrar')) $tipo='DEL';
		elseif ($control) return false;
		else return true;

		$aAcc = $this->_VerifyAction($ent);

		return (bool)$aAcc[$tipo];
	}

	function _VerifyAction($entidad) {
		$oDb = $this->get_db('conf');
		if (!is_object($oDb)) return NULL;
		$oUsr = $this->get_authed_user();
		$mask = $oUsr->get_mask();
		if (!is_numeric($mask) OR empty($entidad)) return NULL;

		if (!is_array($this->_aAcciones[$entidad])) {
			$cons = 'SELECT A.entidad as "entidad", '.
						' (new_mask & '.$mask.') as "NEW", '.
						'new_sub_sec as "NEW_ss_name", '.
						' (edit_mask & '.$mask.') as "EDIT", '.
						'edit_sub_sec as "EDIT_ss_name", '.
						' (del_mask & '.$mask.') as "DEL",  '.
						'del_sub_sec as "DEL_ss_name", '.
						'sel_sub_sec as "SEL_ss_name", '.
						'module_field as "module_field" '.
						'FROM Acciones A '.
						'WHERE entidad = "'.$entidad.'" ';
			$rs = $oDb->query($cons);
			if ($oDb->num_rows($rs)) {
				$aRetVal = $oDb->fetch_assoc($rs);
				$this->_aAcciones[$aRetVal['entidad']] = $aRetVal;
				$aTmp = array('NEW_ss_name','EDIT_ss_name','DEL_ss_name','SEL_ss_name');
				foreach ($aTmp as $ssnm)
					if (!empty($aRetVal[$ssnm])) {
						$aTmp2 = split(' ',$aRetVal[$ssnm]);
						foreach ($aTmp2 as $ssn) {
							if (empty($ssn)) continue;
							if (!is_array($this->_aIdxAccSS[$ssn])) $this->_aIdxAccSS[$ssn] = array();
							if (!in_array($aRetVal['entidad'],$this->_aIdxAccSS[$ssn]))
								array_push($this->_aIdxAccSS[$ssn],$aRetVal['entidad']);
						}
					}
			} else $aRetVal = NULL;
			$oDb->libera($rs);
		} else $aRetVal = $this->_aAcciones[$entidad];

		return $aRetVal;
	}

	function _GetActionBySS($sname) {
		$oDb = $this->get_db('conf');
		if (!is_object($oDb)) return NULL;

		$aDone = $this->get_var('__aSSCheckedForActions');
		if (is_array($aDone) and !sizeof($aDone) and in_array($sname,$aDone)) return true;

		$oUsr = $this->get_authed_user();
		$mask = $oUsr->get_mask();
		if (!is_numeric($mask)) return NULL;
		if (is_array($this->_aAcciones) and sizeof($this->_aAcciones))
			foreach (array_keys($this->_aAcciones) as $k)
				$str_where .= ((!empty($str_where)) ? ' AND ' : '').'A.entidad != "'.$k.'" ';

		$cons = 'SELECT A.entidad as "entidad", '.
					' (new_mask & '.$mask.') as "NEW", '.
					'new_sub_sec as "NEW_ss_name", '.
					' (edit_mask & '.$mask.') as "EDIT", '.
					'edit_sub_sec as "EDIT_ss_name", '.
					' (del_mask & '.$mask.') as "DEL",  '.
					'del_sub_sec as "DEL_ss_name", '.
					'sel_sub_sec as "SEL_ss_name", '.
					'module_field as "module_field" '.
					'FROM Acciones A '.
					'WHERE '.
					'(A.new_sub_sec like "%'.$sname.'%" OR A.edit_sub_sec like "%'.$sname.'%" OR A.del_sub_sec like "%'.$sname.'%" OR A.sel_sub_sec like "%'.$sname.'%" ) '.
					( (!empty($str_where)) ? ' AND ('.$str_where.') ' : '' );
		$rs = $oDb->query($cons);
		if ($oDb->num_rows($rs)) {
			$aRetVal = $oDb->fetch_assoc($rs);
			$this->_aAcciones[$aRetVal['entidad']] = $aRetVal;
			$aTmp = array('NEW_ss_name','EDIT_ss_name','DEL_ss_name');
			foreach ($aTmp as $ssnm)
				if (!empty($aRetVal[$ssnm])) {
					$aTmp2 = split(' ',$aRetVal[$ssnm]);
					foreach ($aTmp2 as $ssn) {
						if (empty($ssn)) continue;
						if (!is_array($this->_aIdxAccSS[$ssn])) $this->_aIdxAccSS[$ssn] = array();
						if (!in_array($aRetVal['entidad'],$this->_aIdxAccSS[$ssn]))
							array_push($this->_aIdxAccSS[$ssn],$aRetVal['entidad']);
					}
				}
			if (!is_array($aDone)) $aDone = array();
			array_push($aDone,$sname);
			$this->set_var('__aSSCheckedForActions',$aDone,'NOEXPIRE');
		} else $aRetVal = NULL;
		$oDb->libera($rs);

		return $aRetVal;
	}


} /******* FIN DE LA CLASE **********/

?>
